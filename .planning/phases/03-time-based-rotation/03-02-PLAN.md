---
phase: 03-time-based-rotation
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/transports/file-transport.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FileTransport schedules midnight rotation when pattern: 'daily' is configured"
    - "Rotation timer is automatically cleaned up when FileTransport is closed"
    - "Time-based and size-based rotation can coexist (hybrid strategy)"
    - "Timer reschedules itself recursively for daily rotation"
  artifacts:
    - path: "src/transports/file-transport.ts"
      provides: "Timer scheduling and cleanup for daily rotation"
      contains: "rotationTimer?: NodeJS.Timeout"
      contains: "scheduleMidnightRotation()"
      contains: "clearRotationTimer()"
      contains: "lastRotationDate?: Date"
      min_lines: 80 (new code)
  key_links:
    - from: "FileTransport.constructor"
      to: "scheduleMidnightRotation()"
      via: "conditional call when pattern === 'daily'"
      pattern: "if.*pattern.*daily.*scheduleMidnightRotation"
    - from: "FileTransport.close()"
      to: "clearRotationTimer()"
      via: "call in close() method"
      pattern: "clearRotationTimer.*before.*stream.end"
    - from: "scheduleMidnightRotation()"
      to: "getMsUntilNextMidnightUTC()"
      via: "import and call"
      pattern: "import.*getMsUntilNextMidnightUTC.*from.*utils/rotation"
---

<objective>
Implement timer-based scheduling for daily log rotation at midnight UTC with automatic cleanup.

Purpose: Enable FileTransport to automatically rotate log files at midnight UTC when daily rotation is configured. Implement recursive timer scheduling for accurate daily triggers and ensure proper cleanup to prevent memory leaks. Support hybrid rotation (time + size) by integrating with existing rotation infrastructure.

Output: FileTransport with timer scheduling, midnight rotation detection, date tracking, and timer cleanup integrated into close() method.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-time-based-rotation/03-RESEARCH.md
@.planning/phases/03-time-based-rotation/03-01-SUMMARY.md

@src/transports/file-transport.ts
@src/utils/rotation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timer state and import getMsUntilNextMidnightUTC</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    1. Add import at top of file:
       ```typescript
       import { getMsUntilNextMidnightUTC } from '../utils/rotation';
       ```

    2. Add private fields to FileTransport class (after existing fields):
       ```typescript
       private readonly timeBasedRotationEnabled: boolean;
       private rotationTimer?: NodeJS.Timeout;
       private lastRotationDate?: Date;
       ```

    3. Update constructor to parse pattern from rotation options:
       - Add `pattern?: 'daily'` to FileTransportOptions interface
       - Set `this.timeBasedRotationEnabled = options?.pattern === 'daily'`
       - Store this value after existing rotationEnabled parsing

    Reference existing constructor structure (lines 170-204).
  </action>
  <verify>
    grep -n "import.*getMsUntilNextMidnightUTC" src/transports/file-transport.ts returns import statement
    grep -n "rotationTimer.*NodeJS.Timeout" src/transports/file-transport.ts returns field declaration
    grep -n "timeBasedRotationEnabled" src/transports/file-transport.ts returns field declaration
  </verify>
  <done>
    FileTransport has timer state fields and imports getMsUntilNextMidnightUTC utility
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement scheduleMidnightRotation method</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Add private method scheduleMidnightRotation() to FileTransport class:

    ```typescript
    private scheduleMidnightRotation(): void {
        // Calculate milliseconds until next midnight UTC
        const msUntilMidnight = getMsUntilNextMidnightUTC();

        // Schedule rotation callback
        this.rotationTimer = setTimeout(() => {
            // Trigger rotation via existing checkSizeAndRotate
            // (which will check time-based condition)
            this.checkSizeAndRotate().catch((err) => {
                console.error(`[FileTransport] Midnight rotation error: ${err instanceof Error ? err.message : String(err)}`);
            });

            // Reschedule for next day (recursive setTimeout prevents drift)
            this.scheduleMidnightRotation();
        }, msUntilMidnight);
    }
    ```

    Key implementation details from research:
    - Use recursive setTimeout (not setInterval) to prevent timing drift
    - Call existing checkSizeAndRotate to reuse rotation deduplication logic
    - Reschedule immediately after callback executes for next day
    - Error handling prevents midnight rotation failures from crashing app

    Research reference: 03-RESEARCH.md Pattern 2 (Recursive Timer Scheduling)

    Place this method after checkSizeAndRotate() method.
  </action>
  <verify>
    grep -n "scheduleMidnightRotation" src/transports/file-transport.ts returns method definition
    grep -A 5 "scheduleMidnightRotation" src/transports/file-transport.ts | grep -q "setTimeout"
    grep -A 10 "scheduleMidnightRotation" src/transports/file-transport.ts | grep -q "scheduleMidnightRotation()" # recursive call
  </verify>
  <done>
    scheduleMidnightRotation method implements recursive timer scheduling for daily rotation
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement clearRotationTimer method and integrate into close()</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    1. Add clearRotationTimer() private method:
       ```typescript
       private clearRotationTimer(): void {
           if (this.rotationTimer) {
               clearTimeout(this.rotationTimer);
               this.rotationTimer = undefined;
           }
       }
       ```

    2. Integrate timer cleanup into close() method:
       - Add call to this.clearRotationTimer() AFTER this.closed = true
       - Add call BEFORE this.stream.removeAllListeners('error')
       - This ensures timer is cleared before stream cleanup

    Reference existing close() method (lines 262-283).

    Research rationale: Uncleared timers prevent garbage collection and cause memory leaks (03-RESEARCH.md Pitfall 1).

    3. Call scheduleMidnightRotation() in constructor:
       - Add at end of constructor, after stream creation
       - Wrap in conditional: `if (this.timeBasedRotationEnabled) { this.scheduleMidnightRotation(); }`
       - Place after this.stream = this.createWriteStream(filePath) line
  </action>
  <verify>
    grep -n "clearRotationTimer" src/transports/file-transport.ts returns method definition
    grep -B 2 -A 2 "removeAllListeners" src/transports/file-transport.ts | grep -q "clearRotationTimer" # cleanup before error handler removal
    grep -A 3 "timeBasedRotationEnabled" src/transports/file-transport.ts | grep -q "scheduleMidnightRotation" # called in constructor
  </verify>
  <done>
    Timer is properly cleaned up in close() method and scheduled in constructor when daily pattern is enabled
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds with no errors
2. scheduleMidnightRotation() method uses recursive setTimeout pattern
3. clearRotationTimer() is called in close() before stream cleanup
4. Constructor schedules timer only when timeBasedRotationEnabled is true
5. No memory leaks from uncleared timers
</verification>

<success_criteria>
1. FileTransport schedules midnight rotation when pattern: 'daily' is configured
2. Timer reschedules itself recursively for continuous daily rotation
3. Timer is cleared in close() method to prevent memory leaks
4. Timer scheduling integrates with existing rotation infrastructure (checkSizeAndRotate)
</success_criteria>

<output>
After completion, create `.planning/phases/03-time-based-rotation/03-02-SUMMARY.md`
</output>
