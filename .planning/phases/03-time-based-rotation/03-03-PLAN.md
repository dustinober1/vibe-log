---
phase: 03-time-based-rotation
plan: 03
type: tdd
wave: 3
depends_on: [03-02]
files_modified:
  - src/transports/file-transport.ts
  - test/file-transport-time-rotation.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Time-based rotation triggers when midnight UTC is passed"
    - "Hybrid rotation (time + size) triggers on either condition"
    - "Timer is cleaned up when FileTransport is closed"
    - "Tests use Vitest fake timers to avoid real delays"
    - "Date comparison prevents double-rotation on same day"
  artifacts:
    - path: "test/file-transport-time-rotation.test.ts"
      provides: "Comprehensive tests for time-based rotation"
      min_lines: 150
    - path: "src/transports/file-transport.ts"
      provides: "Time-based rotation trigger logic integrated into checkSizeAndRotate"
      contains: "isMidnightPassed()"
      contains: "hybrid rotation check (size OR time)"
  key_links:
    - from: "test/file-transport-time-rotation.test.ts"
      to: "FileTransport.checkSizeAndRotate()"
      via: "test invocation of rotation trigger"
      pattern: "vi.useFakeTimers.*advanceTimersByTime"
    - from: "FileTransport.checkSizeAndRotate()"
      to: "FileTransport.isMidnightPassed()"
      via: "method call in rotation check"
      pattern: "isMidnightPassed.*checkSizeAndRotate"
---

<objective>
Implement time-based rotation trigger logic with comprehensive test coverage using TDD methodology.

Purpose: Add date-based rotation detection to FileTransport and ensure midnight rotation triggers correctly. Use TDD to drive implementation of isMidnightPassed() logic and hybrid rotation (size OR time). Write comprehensive tests using Vitest fake timers to verify time-based rotation without real delays.

Output: Working time-based rotation with date tracking, hybrid rotation support, and comprehensive test coverage verifying correct behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-time-based-rotation/03-RESEARCH.md
@.planning/phases/03-time-based-rotation/03-01-SUMMARY.md
@.planning/phases/03-time-based-rotation/03-02-SUMMARY.md

@src/transports/file-transport.ts
@test/file-transport-rotation.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing test for midnight rotation trigger</name>
  <files>test/file-transport-time-rotation.test.ts</files>
  <action>
    Create test file test/file-transport-time-rotation.test.ts with failing tests:

    Test suite structure:
    ```typescript
    import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
    import { FileTransport } from '../src/transports/file-transport';
    import fs from 'fs';
    import path from 'path';

    describe('FileTransport - Time-based Rotation', () => {
        const testDir = './test-logs-time';
        const testFile = path.join(testDir, 'app.log');

        beforeEach(() => {
            vi.useFakeTimers();
            // Clean up test directory
            if (fs.existsSync(testDir)) {
                fs.rmSync(testDir, { recursive: true, force: true });
            }
        });

        afterEach(() => {
            vi.restoreAllMocks();
            // Clean up test directory
            if (fs.existsSync(testDir)) {
                fs.rmSync(testDir, { recursive: true, force: true });
            }
        });

        it('should initialize lastRotationDate on first write', () => {
            const transport = new FileTransport(testFile, { pattern: 'daily' });
            transport.log('test message', { level: 'info', context: 'test', message: 'test', timestamp: new Date() }, {});

            // Verify lastRotationDate is set
            expect(transport['lastRotationDate']).toBeDefined();
        });

        it('should rotate when midnight UTC is passed', async () => {
            const transport = new FileTransport(testFile, { pattern: 'daily' });
            transport.log('first message', { level: 'info', context: 'test', message: 'test', timestamp: new Date() }, {});

            // Get initial date
            const initialDate = transport['lastRotationDate'];

            // Advance time past midnight (25 hours)
            vi.advanceTimersByTime(25 * 60 * 60 * 1000);
            await vi.runAllTimersAsync();

            transport.log('second message', { level: 'info', context: 'test', message: 'test', timestamp: new Date() }, {});

            // Verify rotation occurred (lastRotationDate updated)
            expect(transport['lastRotationDate'].getTime()).toBeGreaterThan(initialDate.getTime());

            await transport.close();
        });

        it('should not rotate when midnight has not passed', () => {
            const transport = new FileTransport(testFile, { pattern: 'daily' });
            transport.log('test message', { level: 'info', context: 'test', message: 'test', timestamp: new Date() }, {});

            const initialDate = transport['lastRotationDate'];

            // Advance time by 1 hour (not past midnight)
            vi.advanceTimersByTime(60 * 60 * 1000);

            transport.log('another message', { level: 'info', context: 'test', message: 'test', timestamp: new Date() }, {});

            // Verify rotation did not occur
            expect(transport['lastRotationDate'].getTime()).toBe(initialDate.getTime());
        });
    });
    ```

    Run tests with `npm test` to verify they FAIL (RED phase).
  </action>
  <verify>
    npm test 2>&1 | grep -q "failing\|FAIL" # Tests should fail initially
  </verify>
  <done>
    Failing tests written for midnight rotation trigger behavior
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement isMidnightPassed and integrate with checkSizeAndRotate</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Implement time-based rotation trigger logic:

    1. Add isMidnightPassed() private method:
       ```typescript
       private isMidnightPassed(): boolean {
           // Initialize lastRotationDate on first call
           if (!this.lastRotationDate) {
               this.lastRotationDate = new Date();
               return false;
           }

           const now = new Date();

           // Compare UTC dates (not timestamps) to detect day change
           const nowUTC = Date.UTC(
               now.getUTCFullYear(),
               now.getUTCMonth(),
               now.getUTCDate()
           );

           const lastUTC = Date.UTC(
               this.lastRotationDate.getUTCFullYear(),
               this.lastRotationDate.getUTCMonth(),
               this.lastRotationDate.getUTCDate()
           );

           // If current UTC day > last rotation UTC day, rotate
           if (nowUTC > lastUTC) {
               this.lastRotationDate = now;
               return true;
           }

           return false;
       }
       ```

    2. Modify checkSizeAndRotate() to support hybrid rotation:
       - Update condition to check both size and time triggers
       - Replace existing size check with: `const sizeTriggered = this.rotationEnabled && this.currentFileSize >= this.maxSize!;`
       - Add: `const timeTriggered = this.timeBasedRotationEnabled && this.isMidnightPassed();`
       - Replace rotation condition with: `if (sizeTriggered || timeTriggered)`

    3. Initialize lastRotationDate in log() method:
       - Add after write gating check: `if (this.timeBasedRotationEnabled && !this.lastRotationDate) { this.lastRotationDate = new Date(); }`

    Research reference: 03-RESEARCH.md Pattern 3 (Hybrid Rotation Trigger) and Pattern 4 (Date Comparison)

    Run `npm test` to verify tests PASS (GREEN phase).
  </action>
  <verify>
    npm test 2>&1 | grep -q "passing\|PASS" # Tests should pass
    grep -n "isMidnightPassed" src/transports/file-transport.ts returns method definition
  </verify>
  <done>
    isMidnightPassed() method implemented and integrated into checkSizeAndRotate for hybrid rotation
  </done>
</task>

<task type="auto">
  <name>Task 3: REFACTOR - Add comprehensive tests for edge cases</name>
  <files>test/file-transport-time-rotation.test.ts</files>
  <action>
    Add additional test cases to cover edge cases:

    1. Test timer cleanup on close:
       ```typescript
       it('should clear rotation timer on close', () => {
           const transport = new FileTransport(testFile, { pattern: 'daily' });

           // Verify timer is scheduled
           expect(transport['rotationTimer']).toBeDefined();

           // Close transport
           transport.close();

           // Verify timer is cleared
           expect(transport['rotationTimer']).toBeUndefined();
       });
       ```

    2. Test hybrid rotation (size + time):
       ```typescript
       it('should trigger rotation on either size or time condition', async () => {
           const transport = new FileTransport(testFile, {
               maxSize: '1KB',
               pattern: 'daily'
           });

           // Write enough to trigger size rotation
           for (let i = 0; i < 100; i++) {
               transport.log('x'.repeat(100), { level: 'info', context: 'test', message: 'test', timestamp: new Date() }, {});
           }

           // Wait for async rotation
           await vi.runAllTimersAsync();

           // Verify file was rotated (check for rotated file)
           const files = fs.readdirSync(testDir).filter(f => f.includes('.log.'));
           expect(files.length).toBeGreaterThan(0);

           await transport.close();
       });
       ```

    3. Test no rotation when pattern not configured:
       ```typescript
       it('should not schedule timer when pattern is not configured', () => {
           const transport = new FileTransport(testFile, { maxSize: '100MB' });

           // Verify timer is not scheduled
           expect(transport['rotationTimer']).toBeUndefined();
       });
       ```

    4. Test date comparison across month boundaries:
       ```typescript
       it('should handle month boundaries correctly', () => {
           const transport = new FileTransport(testFile, { pattern: 'daily' });

           // Set date to Jan 31, 2026 23:00 UTC
           vi.setSystemTime(new Date('2026-01-31T23:00:00Z'));
           transport.log('test', { level: 'info', context: 'test', message: 'test', timestamp: new Date() }, {});

           const initialDate = transport['lastRotationDate'];

           // Advance to Feb 1, 2026 01:00 UTC
           vi.setSystemTime(new Date('2026-02-01T01:00:00Z'));
           transport.log('test', { level: 'info', context: 'test', message: 'test', timestamp: new Date() }, {});

           // Verify rotation occurred (date changed)
           expect(transport['lastRotationDate'].getUTCMonth()).toBe(1); // February
       });
       ```

    Run `npm test` to verify all tests pass including edge cases.
  </action>
  <verify>
    npm test 2>&1 | grep -q "passing" && npm test 2>&1 | grep -v "failing"
  </verify>
  <done>
    Comprehensive test coverage for time-based rotation including edge cases
  </done>
</task>

</tasks>

<verification>
1. All time-based rotation tests pass (npm test shows 100% passing)
2. isMidnightPassed() correctly detects UTC day changes
3. Hybrid rotation (size OR time) triggers correctly
4. Timer cleanup prevents memory leaks
5. Date comparison handles month/year boundaries
6. Test coverage maintained or improved
</verification>

<success_criteria>
1. Time-based rotation triggers when midnight UTC is passed
2. Hybrid rotation (size + time) triggers on either condition
3. Timer is properly cleaned up on close
4. Comprehensive test coverage using Vitest fake timers
5. Date comparison logic handles edge cases (month boundaries, year transitions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-time-based-rotation/03-03-SUMMARY.md`
</output>
