---
phase: 06-error-handling-hardening
plan: 05
type: execute
wave: 2
depends_on: []
files_modified:
  - docs/MONITORING.md
autonomous: true
user_setup: []

must_haves:
  truths:
    - "MONITORING.md exists in docs directory"
    - "Health check patterns documented with code examples"
    - "Error event monitoring covered (error, disk-full, permission-denied)"
    - "Log file health checks documented"
    - "Rotation monitoring examples provided"
    - "Disk usage monitoring covered"
    - "Alerting strategies documented"
    - "Metrics collection guide included"
    - "Cross-reference to TROUBLESHOOTING.md"
  artifacts:
    - path: "docs/MONITORING.md"
      provides: "Production monitoring guide for log-vibe"
      contains: "Health Checks, Error Events, Metrics, Alerts"
  key_links:
    - from: "README.md"
      to: "docs/MONITORING.md"
      via: "monitoring link"
      pattern: "MONITORING\\.md"
    - from: "docs/TROUBLESHOOTING.md"
      to: "docs/MONITORING.md"
      via: "cross-reference"
      pattern: "Monitoring Guide"
---

<objective>
Create production monitoring documentation covering health checks, error event handling, log file monitoring, rotation status, and alerting patterns.

Purpose: Provide operators with guidance for monitoring log-vibe in production including health checks, error event listeners, metrics collection, and alerting setup.

Output: docs/MONITORING.md with health monitoring patterns, error event examples, and production alerting strategies.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/06-error-handling-hardening/06-CONTEXT.md
@.planning/phases/06-error-handling-hardening/06-RESEARCH.md
@.planning/STATE.md

@README.md
</context>

<tasks>

<task type="auto">
  <name>Create MONITORING.md file with header and table of contents</name>
  <files>docs/MONITORING.md</files>
  <action>
    Create MONITORING.md with the following structure:

    ```markdown
    # Monitoring Guide

    This guide covers production monitoring for log-vibe, including health checks, error event handling, metrics collection, and alerting.

    ## Table of Contents

    - [Health Checks](#health-checks)
    - [Error Event Monitoring](#error-event-monitoring)
    - [Log File Health](#log-file-health)
    - [Rotation Monitoring](#rotation-monitoring)
    - [Disk Usage Monitoring](#disk-usage-monitoring)
    - [Alerting Strategies](#alerting-strategies)
    - [Metrics Collection](#metrics-collection)
    ```

    Create the docs directory first if it doesn't exist: mkdir -p docs
  </action>
  <verify>
    test -f docs/MONITORING.md && grep -q "Monitoring Guide" docs/MONITORING.md && grep -q "Table of Contents" docs/MONITORING.md
  </verify>
  <done>
    MONITORING.md file created with table of contents
  </done>
</task>

<task type="auto">
  <name>Add Health Checks section with transport health examples</name>
  <files>docs/MONITORING.md</files>
  <action>
    Append the Health Checks section after the table of contents:

    ```markdown
    ## Health Checks

    ### Basic Transport Health

    Monitor the health of your log transports by listening to events:

    ```typescript
    import { FileTransport } from 'log-vibe';

    const transport = new FileTransport('./logs/app.log', {
      maxSize: '100MB',
      maxFiles: 20,
      maxAge: 30
    });

    // Monitor for any errors
    transport.on('error', (err) => {
      console.error('[ALERT] Transport error:', {
        code: err.code,
        message: err.message,
        timestamp: new Date().toISOString()
      });
    });

    // Monitor for disk full
    transport.on('disk-full', (err) => {
      console.error('[CRITICAL] Disk full - logging stopped:', {
        path: './logs/app.log',
        timestamp: new Date().toISOString()
      });
      // Send alert to monitoring system
      sendAlert('disk-full', { path: './logs/app.log' });
    });

    // Monitor for permission denied
    transport.on('permission-denied', (err) => {
      console.error('[CRITICAL] Permission denied - logging stopped:', {
        path: './logs/app.log',
        timestamp: new Date().toISOString()
      });
      // Send alert to monitoring system
      sendAlert('permission-denied', { path: './logs/app.log' });
    });

    configure({ transports: [transport] });
    ```

    ### Health Check Endpoint

    For web applications, add a health check endpoint:

    ```typescript
    import express from 'express';
    import { FileTransport } from 'log-vibe';

    const app = express();
    const transport = new FileTransport('./logs/app.log');

    let healthStatus = 'healthy';
    let lastError = null;

    transport.on('error', (err) => {
      healthStatus = 'unhealthy';
      lastError = {
        code: err.code,
        message: err.message,
        timestamp: new Date().toISOString()
      };
    });

    transport.on('disk-full', () => {
      healthStatus = 'critical';
    });

    app.get('/health', (req, res) => {
      const health = {
        status: healthStatus,
        timestamp: new Date().toISOString(),
        logging: {
          healthy: healthStatus === 'healthy',
          lastError: lastError
        }
      };

      const statusCode = healthStatus === 'healthy' ? 200 : 503;
      res.status(statusCode).json(health);
    });

    app.listen(3000);
    ```

    ### Health Check Script

    Create a standalone health check script:

    ```bash
    #!/bin/bash
    # health-check.sh

    LOG_DIR="./logs"
    LOG_FILE="$LOG_DIR/app.log"
    MAX_SIZE=$((100 * 1024 * 1024))  # 100MB

    # Check if log file exists
    if [ ! -f "$LOG_FILE" ]; then
      echo "CRITICAL: Log file does not exist"
      exit 2
    fi

    # Check if log file is writable
    if [ ! -w "$LOG_FILE" ]; then
      echo "CRITICAL: Log file is not writable"
      exit 2
    fi

    # Check log file size
    SIZE=$(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE" 2>/dev/null)
    if [ "$SIZE" -gt "$MAX_SIZE" ]; then
      echo "WARNING: Log file exceeds $MAX_SIZE bytes"
      exit 1
    fi

    # Check disk space
    DISK_USAGE=$(df "$LOG_DIR" | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ "$DISK_USAGE" -gt 90 ]; then
      echo "CRITICAL: Disk usage at ${DISK_USAGE}%"
      exit 2
    fi

    echo "OK: Logging system healthy"
    exit 0
    ```
    ```
  </action>
  <verify>
    grep -q "## Health Checks" docs/MONITORING.md && grep -q "Basic Transport Health" docs/MONITORING.md && grep -q "Health Check Endpoint" docs/MONITORING.md
  </verify>
  <done>
    Health Checks section with transport health, endpoint, and script examples added
  </done>
</task>

<task type="auto">
  <name>Add Error Event Monitoring and Log File Health sections</name>
  <files>docs/MONITORING.md</files>
  <action>
    Append the Error Event Monitoring and Log File Health sections after Health Checks:

    ```markdown
    ## Error Event Monitoring

    ### Error Categories

    log-vibe emits different error events based on the error type:

    | Event | Error Code | Severity | Action Required |
    |-------|-----------|----------|-----------------|
    | `error` | Any | Warning | Monitor for patterns |
    | `disk-full` | ENOSPC | Critical | Free disk space immediately |
    | `permission-denied` | EACCES | Critical | Fix permissions or restart |

    ### Comprehensive Error Handler

    ```typescript
    import { FileTransport } from 'log-vibe';
    import { promisify } from 'util';

    const transport = new FileTransport('./logs/app.log', {
      maxSize: '100MB'
    });

    // Error statistics
    const errorStats = {
      total: 0,
      byCode: new Map<string, number>(),
      lastError: null as { code: string; message: string; time: Date } | null
    };

    // General error handler
    transport.on('error', (err: NodeJS.ErrnoException) => {
      errorStats.total++;
      errorStats.byCode.set(err.code, (errorStats.byCode.get(err.code) || 0) + 1);
      errorStats.lastError = {
        code: err.code,
        message: err.message,
        time: new Date()
      };

      // Log for monitoring
      console.error('[MONITOR] Transport error:', {
        code: err.code,
        message: err.message,
        totalErrors: errorStats.total,
        errorsByCode: Object.fromEntries(errorStats.byCode)
      });

      // Alert on repeated errors
      const count = errorStats.byCode.get(err.code) || 0;
      if (count >= 5) {
        console.error(`[ALERT] Error ${err.code} occurred ${count} times`);
        sendAlert('repeated-error', { code: err.code, count });
      }
    });

    // Critical error handlers
    transport.on('disk-full', (err) => {
      console.error('[CRITICAL] Disk full - take immediate action');
      sendAlert('disk-full', { path: './logs/app.log' });

      // Send to monitoring service
      notifyPagerDuty({
        summary: 'Log disk full',
        severity: 'critical',
        details: { path: './logs/app.log' }
      });
    });

    transport.on('permission-denied', (err) => {
      console.error('[CRITICAL] Permission denied - logging stopped');
      sendAlert('permission-denied', { path: './logs/app.log' });
    });

    // Get error stats for monitoring
    function getErrorStats() {
      return {
        total: errorStats.total,
        byCode: Object.fromEntries(errorStats.byCode),
        lastError: errorStats.lastError
      };
    }
    ```

    ## Log File Health

    ### File Size Monitoring

    Monitor log file sizes to detect issues:

    ```typescript
    import fs from 'fs/promises';
    import path from 'path';

    async function checkLogHealth(logDir: string, baseName: string) {
      const files = await fs.readdir(logDir);
      const logFiles = files.filter(f => f.startsWith(baseName));

      const health = {
        totalFiles: logFiles.length,
        totalSize: 0,
        oldestFile: null,
        newestFile: null,
        issues: []
      };

      for (const file of logFiles) {
        const filePath = path.join(logDir, file);
        const stats = await fs.stat(filePath);

        health.totalSize += stats.size;

        if (!health.oldestFile || stats.mtime < health.oldestFile.mtime) {
          health.oldestFile = { name: file, mtime: stats.mtime, size: stats.size };
        }

        if (!health.newestFile || stats.mtime > health.newestFile.mtime) {
          health.newestFile = { name: file, mtime: stats.mtime, size: stats.size };
        }

        // Check for very large files (may indicate rotation not working)
        const maxSize = 200 * 1024 * 1024; // 200MB
        if (stats.size > maxSize && !file.includes('.log.')) {
          health.issues.push(`Large active file: ${file} (${Math.round(stats.size / 1024 / 1024)}MB)`);
        }
      }

      return health;
    }

    // Usage
    setInterval(async () => {
      const health = await checkLogHealth('./logs', 'app');
      console.log('[HEALTH] Log file status:', health);

      if (health.issues.length > 0) {
        console.error('[ALERT] Log health issues:', health.issues);
      }
    }, 60000); // Check every minute
    ```

    ### File Age Monitoring

    Monitor log file ages to detect stale logs:

    ```typescript
    async function checkLogFreshness(logFile: string, maxAgeMinutes = 10) {
      try {
        const stats = await fs.stat(logFile);
        const ageMs = Date.now() - stats.mtimeMs;
        const ageMinutes = ageMs / 60000;

        if (ageMinutes > maxAgeMinutes) {
          console.error(`[ALERT] Log file is stale: ${logFile} (${Math.round(ageMinutes)} minutes old)`);
          return false;
        }

        return true;
      } catch (error) {
        console.error(`[ALERT] Cannot access log file: ${logFile}`);
        return false;
      }
    }
    ```
    ```
  </action>
  <verify>
    grep -q "## Error Event Monitoring" docs/MONITORING.md && grep -q "## Log File Health" docs/MONITORING.md && grep -q "File Size Monitoring" docs/MONITORING.md
  </verify>
  <done>
    Error Event Monitoring and Log File Health sections added
  </done>
</task>

<task type="auto">
  <name>Add Rotation Monitoring and Disk Usage Monitoring sections</name>
  <files>docs/MONITORING.md</files>
  <action>
    Append the Rotation Monitoring and Disk Usage Monitoring sections:

    ```markdown
    ## Rotation Monitoring

    ### Rotation Status

    Monitor rotation activity to ensure it's working:

    ```typescript
    import fs from 'fs/promises';

    async function getRotationStatus(logDir: string, baseName: string) {
      const files = await fs.readdir(logDir);
      const rotatedFiles = files.filter(f => f.includes(`${baseName}-`) && f.includes('.log.'));

      const rotationCount = rotatedFiles.length;
      const latestRotated = rotatedFiles.sort().reverse()[0];

      return {
        rotationCount,
        latestRotated,
        lastRotationDate: latestRotated
          ? (await fs.stat(path.join(logDir, latestRotated))).mtime
          : null
      };
    }

    // Monitor rotation
    setInterval(async () => {
      const status = await getRotationStatus('./logs', 'app');
      console.log('[MONITOR] Rotation status:', {
        totalRotations: status.rotationCount,
        latestRotation: status.lastRotationDate
      });

      // Alert if no rotation in 24 hours (for active applications)
      const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
      if (status.lastRotationDate && status.lastRotationDate < dayAgo) {
        console.error('[ALERT] No rotation in 24 hours - rotation may be broken');
      }
    }, 300000); // Check every 5 minutes
    ```

    ### Rotation Failure Detection

    Detect when rotation fails:

    ```typescript
    import { FileTransport } from 'log-vibe';

    const transport = new FileTransport('./logs/app.log', {
      maxSize: '100MB'
    });

    let rotationFailures = 0;

    transport.on('error', (err) => {
      if (err.code === 'ENOSPC' || err.code === 'EACCES') {
        rotationFailures++;
        console.error(`[ALERT] Rotation failure #${rotationFailures}:`, err.code);
      }
    });
    ```

    ## Disk Usage Monitoring

    ### Disk Space Checks

    Monitor disk space to prevent ENOSPC errors:

    ```typescript
    import { exec } from 'child_process';
    import { promisify } from 'util';

    const execAsync = promisify(exec);

    async function getDiskUsage(path: string) {
      try {
        const { stdout } = await execAsync(`df -h "${path}"`);
        const lines = stdout.split('\n');
        const data = lines[1].split(/\s+/);

        return {
          filesystem: data[0],
          size: data[1],
          used: data[2],
          available: data[3],
          usagePercent: parseInt(data[4].replace('%', '')),
          mountpoint: data[5]
        };
      } catch (error) {
        console.error('Failed to get disk usage:', error);
        return null;
      }
    }

    // Monitor disk usage
    setInterval(async () => {
      const usage = await getDiskUsage('./logs');

      if (usage) {
        console.log('[MONITOR] Disk usage:', usage);

        // Alert at 80% warning
        if (usage.usagePercent >= 80) {
          console.error(`[WARNING] Disk usage at ${usage.usagePercent}%`);
        }

        // Critical alert at 90%
        if (usage.usagePercent >= 90) {
          console.error(`[CRITICAL] Disk usage at ${usage.usagePercent}% - immediate action required`);
          sendAlert('disk-space-critical', {
            usagePercent: usage.usagePercent,
            available: usage.available
          });
        }
      }
    }, 300000); // Check every 5 minutes
    ```

    ### Log Directory Size

    Monitor total log directory size:

    ```bash
    #!/bin/bash
    # check-log-size.sh

    LOG_DIR="./logs"
    MAX_SIZE=$((10 * 1024 * 1024 * 1024))  # 10GB

    # Get directory size (Linux)
    SIZE=$(du -sb "$LOG_DIR" | cut -f1)

    # Get directory size (macOS)
    if [ -z "$SIZE" ]; then
      SIZE=$(du -s "$LOG_DIR" | cut -f1)
      SIZE=$((SIZE * 512))  # Convert blocks to bytes
    fi

    SIZE_GB=$((SIZE / 1024 / 1024 / 1024))

    echo "Log directory size: ${SIZE_GB}GB"

    if [ "$SIZE" -gt "$MAX_SIZE" ]; then
      echo "CRITICAL: Log directory exceeds ${MAX_SIZE} bytes"
      exit 2
    fi

    exit 0
    ```
    ```
  </action>
  <verify>
    grep -q "## Rotation Monitoring" docs/MONITORING.md && grep -q "## Disk Usage Monitoring" docs/MONITORING.md && grep -q "Disk Space Checks" docs/MONITORING.md
  </verify>
  <done>
    Rotation Monitoring and Disk Usage Monitoring sections added
  </done>
</task>

<task type="auto">
  <name>Add Alerting Strategies and Metrics Collection sections</name>
  <files>docs/MONITORING.md</files>
  <action>
    Append the Alerting Strategies and Metrics Collection sections at the end:

    ```markdown
    ## Alerting Strategies

    ### Alert Levels

    | Level | Threshold | Action |
    |-------|-----------|--------|
    | Info | Rotation occurred | Log only |
    | Warning | Disk at 80% | Send warning alert |
    | Critical | Disk at 90% | Page on-call engineer |
    | Critical | Disk full (ENOSPC) | Page immediately |
    | Critical | Permission denied | Page immediately |
    | Warning | No rotation in 24h | Investigate |

    ### Alert Integration Examples

    **Send to Slack:**
    ```typescript
    async function sendSlackAlert(level: string, message: string, details: any) {
      const webhook = process.env.SLACK_WEBHOOK_URL;

      await fetch(webhook, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: `[${level.toUpperCase()}] ${message}`,
          attachments: [{ text: JSON.stringify(details, null, 2) }]
        })
      });
    }

    transport.on('disk-full', (err) => {
      sendSlackAlert('critical', 'Log disk full', {
        path: './logs/app.log',
        error: err.message
      });
    });
    ```

    **Send to Email:**
    ```typescript
    import nodemailer from 'nodemailer';

    const transporter = nodemailer.createTransport({
      host: 'smtp.example.com',
      auth: { user, pass }
    });

    async function sendEmailAlert(level: string, subject: string, details: any) {
      await transporter.sendMail({
        from: 'alerts@example.com',
        to: 'oncall@example.com',
        subject: `[${level.toUpperCase()}] ${subject}`,
        text: JSON.stringify(details, null, 2)
      });
    }

    transport.on('permission-denied', (err) => {
      sendEmailAlert('critical', 'Log permission denied', {
        path: './logs/app.log',
        error: err.message,
        timestamp: new Date()
      });
    });
    ```

    **Send to Prometheus Pushgateway:**
    ```typescript
    async function sendToPrometheus(metric: string, value: number, labels: Record<string, string>) {
      const url = process.env.PROMETHEUS_PUSHGATEWAY;
      const labelStr = Object.entries(labels).map(([k, v]) => `${k}="${v}"`).join(',');

      await fetch(`${url}/metrics/job/log-vibe/${metric}`, {
        method: 'POST',
        body: `${metric}{${labelStr}} ${value}\n`
      });
    }

    transport.on('error', (err) => {
      sendToPrometheus('log_vibe_errors_total', 1, {
        code: err.code,
        path: './logs/app.log'
      });
    });
    ```

    ## Metrics Collection

    ### Key Metrics to Track

    1. **Error count by type**: Total errors, ENOSPC, EACCES, etc.
    2. **Rotation count**: Number of rotations performed
    3. **Disk usage**: Percentage and available space
    4. **Log file count**: Total log files in directory
    5. **Log directory size**: Total bytes used by logs
    6. **Write latency**: Time to write log entries
    7. **Rotation latency**: Time to complete rotation

    ### Metrics Dashboard

    Create a metrics endpoint for dashboards:

    ```typescript
    import express from 'express';

    const app = express();
    const metrics = {
      errors: { total: 0, byCode: {} },
      rotations: { total: 0, lastTime: null },
      diskUsage: { percent: 0, available: '0' }
    };

    app.get('/metrics', (req, res) => {
      res.json(metrics);
    });

    // Update metrics
    transport.on('error', (err) => {
      metrics.errors.total++;
      metrics.errors.byCode[err.code] = (metrics.errors.byCode[err.code] || 0) + 1;
    });

    transport.on('rotation', () => {
      metrics.rotations.total++;
      metrics.rotations.lastTime = new Date();
    });
    ```

    ---

    *See also: [Troubleshooting Guide](./TROUBLESHOOTING.md)*
    ```
  </action>
  <verify>
    grep -q "## Alerting Strategies" docs/MONITORING.md && grep -q "## Metrics Collection" docs/MONITORING.md && grep -q "TROUBLESHOOTING.md" docs/MONITORING.md
  </verify>
  <done>
    Alerting Strategies and Metrics Collection sections added with cross-reference
  </done>
</task>

</tasks>

<verification>
- docs/MONITORING.md exists
- Health check patterns documented with code examples
- Error event monitoring covered (error, disk-full, permission-denied)
- Log file health checks documented
- Rotation monitoring examples provided
- Disk usage monitoring covered
- Alerting strategies documented
- Metrics collection guide included
- Cross-reference to TROUBLESHOOTING.md
</verification>

<success_criteria>
- All monitoring patterns covered with executable examples
- Error event handling clearly documented
- Health check endpoint example provided
- Shell script examples for monitoring
- Alert integration examples (Slack, Email, Prometheus)
- Production-ready monitoring patterns
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-handling-hardening/06-05-SUMMARY.md`
</output>
