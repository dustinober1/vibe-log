---
phase: 06-error-handling-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/transports/file-transport.ts
  - src/transports/transport.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "log() never throws or blocks even when transport errors occur"
    - "Transport errors emit 'error' events on FileTransport"
    - "Stream errors are caught and logged to console.error"
    - "ENOSPC (disk full) stops writes with 'disk-full' event"
    - "EACCES (permission denied) stops writes with 'permission-denied' event"
    - "Application continues running after transport errors"
  artifacts:
    - path: "src/transports/file-transport.ts"
      provides: "Enhanced error handling with EventEmitter and error classification"
      contains: "class FileTransport extends EventEmitter"
    - path: "src/transports/transport.ts"
      provides: "Transport interface with error handling documentation"
      contains: "interface Transport"
  key_links:
    - from: "src/transports/file-transport.ts"
      to: "events"
      via: "extends EventEmitter"
      pattern: "import.*EventEmitter.*from.*events"
    - from: "FileTransport.attachErrorHandler"
      to: "console.error"
      via: "fallback error logging"
      pattern: "console\\.error.*Write error"
---

<objective>
Implement production-ready error handling strategy for FileTransport using EventEmitter pattern with error classification for ENOSPC and EACCES errors.

Purpose: Ensure logging never crashes the application by catching all errors, emitting events for monitoring, and implementing error-specific handling for critical production errors.

Output: Enhanced FileTransport with EventEmitter inheritance, error classification, and event emission for disk-full and permission-denied errors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/06-error-handling-hardening/06-CONTEXT.md
@.planning/phases/06-error-handling-hardening/06-RESEARCH.md
@.planning/STATE.md

@src/transports/file-transport.ts
@src/transports/transport.ts
</context>

<tasks>

<task type="auto">
  <name>Extend FileTransport with EventEmitter</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Import EventEmitter from 'events' and extend FileTransport class:

    1. Add import: import { EventEmitter } from 'events';
    2. Change class declaration: export class FileTransport extends EventEmitter implements Transport
    3. No other changes needed - EventEmitter provides emit() and on() methods

    This enables FileTransport to emit 'error', 'disk-full', and 'permission-denied' events that applications can listen to for monitoring.
  </action>
  <verify>
    grep -n "class FileTransport extends EventEmitter" src/transports/file-transport.ts
  </verify>
  <done>
    FileTransport extends EventEmitter and can emit events for error monitoring
  </done>
</task>

<task type="auto">
  <name>Add error classification utility</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Add private classifyError method and error constants before the FileTransport class:

    ```typescript
    // Error classification for production error handling
    enum ErrorClass {
        TRANSIENT = 'TRANSIENT',   // Safe to retry
        PERMANENT = 'PERMANENT',   // User action required
        UNKNOWN = 'UNKNOWN'         // Needs investigation
    }

    const ERROR_CLASSIFICATIONS: Record<string, ErrorClass> = {
        // Transient errors - safe to retry
        'EBUSY': ErrorClass.TRANSIENT,
        'EAGAIN': ErrorClass.TRANSIENT,
        'EINTR': ErrorClass.TRANSIENT,

        // Permanent errors - don't retry
        'ENOSPC': ErrorClass.PERMANENT,     // Disk full
        'EACCES': ErrorClass.PERMANENT,     // Permission denied
        'ENOENT': ErrorClass.PERMANENT,
        'EISDIR': ErrorClass.PERMANENT,
        'ENOTDIR': ErrorClass.PERMANENT,
    };

    function classifyError(error: NodeJS.ErrnoException): ErrorClass {
        return ERROR_CLASSIFICATIONS[error.code] || ErrorClass.UNKNOWN;
    }
    ```

    Place this before the FileTransport class definition but after imports.
  </action>
  <verify>
    grep -n "classifyError\|ErrorClass\|ERROR_CLASSIFICATIONS" src/transports/file-transport.ts
  </verify>
  <done>
    Error classification utility identifies ENOSPC and EACCES as permanent errors
  </done>
</task>

<task type="auto">
  <name>Enhance stream error handler with event emission</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Update the attachErrorHandler method to emit events and handle ENOSPC/EACCES:

    Replace the existing attachErrorHandler method with:

    ```typescript
    private attachErrorHandler(stream: fs.WriteStream): void {
        stream.on('error', (err: NodeJS.ErrnoException) => {
            // 1. Emit to application for monitoring
            this.emit('error', err);

            // 2. Log to console (never crash the app)
            console.error(`[FileTransport] Write error for ${this.filePath}: ${err.code} - ${err.message}`);

            // 3. Error-specific handling
            if (err.code === 'ENOSPC') {
                // Disk full - stop accepting writes
                this.rotating = true;
                this.emit('disk-full', err);
            } else if (err.code === 'EACCES') {
                // Permission denied - fail permanently
                this.closed = true;
                this.emit('permission-denied', err);
            }
        });
    }
    ```

    This ensures:
    - All errors emit 'error' event for general monitoring
    - Disk full errors stop writes and emit 'disk-full' event
    - Permission errors permanently stop transport and emit 'permission-denied' event
    - Console.error provides fallback logging
  </action>
  <verify>
    grep -A 10 "private attachErrorHandler" src/transports/file-transport.ts | grep -E "emit\(|ENOSPC|EACCES"
  </verify>
  <done>
    Stream errors emit events, log to console, and implement error-specific handling for ENOSPC and EACCES
  </done>
</task>

<task type="auto">
  <name>Update Transport interface error handling documentation</name>
  <files>src/transports/transport.ts</files>
  <action>
    Update the Transport interface documentation to mention event emission for error handling.

    Add to the log() method remarks:

    ```typescript
    * @remarks
    * This method MUST be synchronous. If a transport needs async
    * operations (e.g., network requests), it should handle them
    * internally without blocking the log call.
    *
    * This method MUST NOT throw. Errors should be caught and
    * handled gracefully. For production error handling, transports
    * should:
    * - Emit 'error' events for monitoring
    * - Log to console.error as fallback
    * - Never crash the application
    ```
  </action>
  <verify>
    grep -A 5 "This method MUST NOT throw" src/transports/transport.ts | grep "Emit 'error' events"
  </verify>
  <done>
    Transport interface documents event emission pattern for error handling
  </done>
</task>

</tasks>

<verification>
- FileTransport extends EventEmitter
- Error classification utility classifies ENOSPC and EACCES as permanent errors
- attachErrorHandler emits 'error' events for all errors
- ENOSPC errors set rotating=true and emit 'disk-full' event
- EACCES errors set closed=true and emit 'permission-denied' event
- All errors logged to console.error
- log() method never throws (catch block in log() swallows errors)
- Transport interface documents event emission pattern
</verification>

<success_criteria>
- Applications can listen for 'error', 'disk-full', and 'permission-denied' events
- log() never throws or blocks even when disk is full
- Permission errors permanently stop writes with clear event emission
- Console.error provides fallback logging when transport fails
- Error classification distinguishes permanent from transient errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-handling-hardening/06-01-SUMMARY.md`
</output>
