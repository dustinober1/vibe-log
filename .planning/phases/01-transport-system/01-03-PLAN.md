---
phase: 01-transport-system
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/config.ts
  - src/logger.ts
  - src/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "configure() accepts transports array"
    - "configure() converts file shorthand to FileTransport"
    - "Default transports include ConsoleTransport"
    - "Logger writes to all configured transports"
    - "Existing code works without changes (backward compatible)"
    - "Console output appears in console by default"
  artifacts:
    - path: "src/config.ts"
      provides: "Extended configuration with transport support"
      contains: "FileTransport"
      min_lines: 80
    - path: "src/logger.ts"
      provides: "Transport-aware logging implementation"
      contains: "transports"
      min_lines: 130
    - path: "src/index.ts"
      provides: "Public API exports for transports"
      contains: "Transport"
      min_lines: 40
  key_links:
    - from: "src/config.ts"
      to: "src/transports/file-transport.ts"
      via: "import { FileTransport }"
      pattern: "import.*FileTransport"
    - from: "src/config.ts"
      to: "src/transports/console-transport.ts"
      via: "import { ConsoleTransport }"
      pattern: "import.*ConsoleTransport"
    - from: "src/logger.ts"
      to: "src/config.ts"
      via: "getConfig() to read transports array"
      pattern: "getConfig\(\)"
    - from: "src/logger.ts"
      to: "Transport interface"
      via: "Calling transport.log() for each transport"
      pattern: "transport\.log\("
---

<objective>
Integrate transport system into logger and configuration. Wire up transports so logs are written to all configured destinations while maintaining full backward compatibility with existing code.

Purpose: Connect the transport implementations to the logger core. Enable users to configure transports via configure() while preserving existing behavior (console output by default).

Output: Working transport system with backward-compatible defaults.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-transport-system/01-CONTEXT.md
@.planning/phases/01-transport-system/01-RESEARCH.md

@src/config.ts
@src/logger.ts
@src/index.ts
@src/types.ts
@src/transports/transport.ts
@src/transports/file-transport.ts
@src/transports/console-transport.ts
</context>

<tasks>

<task type="auto">
  <name>Update config.ts for transport support</name>
  <files>src/config.ts</files>
  <action>
    Update src/config.ts to handle transport configuration:

    1. Add imports at top of file (after existing imports):
    ```typescript
    import { FileTransport } from './transports/file-transport';
    import { ConsoleTransport } from './transports/console-transport';
    import type { Transport } from './transports/transport';
    ```

    2. Update defaultConfig to include console field (add after timestampFormat):
    ```typescript
    console: true,
    ```

    3. Replace the configure() function with this enhanced version:
    ```typescript
    export function configure(config: Partial<LoggerConfig>): Required<LoggerConfig> {
        // File shorthand: convert file string to FileTransport
        if (config.file && !config.transports) {
            const fileTransport = new FileTransport(config.file);
            config.transports = [fileTransport];
        }

        // Handle transports configuration
        if (config.transports !== undefined) {
            // User provided explicit transports array
            currentConfig.transports = config.transports;
        }

        // Handle console flag
        if (config.console !== undefined) {
            currentConfig.console = config.console;
        }

        // Merge all other config fields
        const { file, transports, console: _console, ...otherConfig } = config;
        currentConfig = { ...currentConfig, ...otherConfig };

        // Build default transports if none set
        if (!currentConfig.transports) {
            buildDefaultTransports();
        }

        return { ...currentConfig };
    }
    ```

    4. Add helper function after resetConfig():
    ```typescript
    /**
     * Build default transports array based on console setting
     */
    function buildDefaultTransports(): void {
        if (currentConfig.console) {
            currentConfig.transports = [new ConsoleTransport()];
        } else {
            currentConfig.transports = [];
        }
    }
    ```

    5. Initialize default transports at the end of file (after defaultConfig definition):
    ```typescript
    // Initialize default transports on module load
    buildDefaultTransports();
    ```

    CRITICAL: Maintain backward compatibility
    - If user doesn't specify transports, default to [ConsoleTransport]
    - File shorthand creates FileTransport and sets transports array
    - Existing config fields (level, showTimestamp, etc.) still work
    - Empty transports array silences all output

    Do NOT:
    - Remove existing config fields
    - Change default values for existing fields
    - Make transports required (must be optional)
  </action>
  <verify>
    File contains:
    - Imports for FileTransport, ConsoleTransport, Transport type
    - configure() handles file shorthand
    - configure() handles transports array
    - configure() handles console boolean flag
    - buildDefaultTransports() helper function
    - Default transports initialized on load
    - All existing config fields preserved

    Check: `grep -E "(FileTransport|ConsoleTransport|buildDefaultTransports|transports)" src/config.ts`
  </verify>
  <done>
    Configuration updated with:
    - Transport imports and types
    - File shorthand conversion (file: './app.log' -> FileTransport)
    - Transports array handling
    - Console flag support
    - Default transports initialization
    - Full backward compatibility
  </done>
</task>

<task type="auto">
  <name>Update logger.ts to use transports</name>
  <files>src/logger.ts</files>
  <action>
    Update src/logger.ts to write to transports instead of console:

    Replace the writeLog function entirely with this implementation:

    ```typescript
    function writeLog(
        level: LogLevel,
        context: string,
        message: string,
        data?: unknown[]
    ): void {
        // Input validation
        if (!context || !context.trim()) {
            throw new Error('Context cannot be empty or whitespace');
        }

        if (!message || !message.trim()) {
            throw new Error('Message cannot be empty or whitespace');
        }

        // Check if this level should be logged
        const config = getConfig();
        if (!shouldLog(level, config.level)) {
            return;
        }

        const entry: LogEntry = {
            level,
            context,
            message,
            data,
            timestamp: new Date(),
        };

        const formatted = formatLogEntry(entry);

        // Write to all configured transports
        const transports = config.transports || [];
        for (const transport of transports) {
            try {
                transport.log(formatted, entry, config);
            } catch (error) {
                // Transport failed - log to stderr as fallback
                // Don't let transport failures crash the application
                const err = error as Error;
                console.error(`[log-vibe] Transport error: ${err.message}`);
            }
        }
    }
    ```

    Key changes:
    - Removed direct console method calls
    - Added loop over transports array
    - Each transport.log() called with (formatted, entry, config)
    - Wrapped in try-catch to prevent transport failures from crashing app
    - Falls back to console.error on transport failure

    CRITICAL: This must be backward compatible
    - Default transports = [ConsoleTransport] maintains existing behavior
    - Existing tests should pass without modification
    - No changes to function signatures

    Do NOT:
    - Change function signature
    - Add new parameters
    - Make the function async
    - Remove input validation
  </action>
  <verify>
    File contains:
    - Loop over transports array
    - transport.log(formatted, entry, config) call
    - try-catch around transport.log()
    - Fallback to console.error on transport failure
    - Input validation preserved
    - No direct console.error/warn/debug/log calls in writeLog

    Check: `grep -A 5 "for (const transport" src/logger.ts`
  </verify>
  <done>
    Logger updated with:
    - Transport-aware log writing
    - All transports receive formatted output
    - Error handling for failed transports
    - Backward compatible behavior
  </done>
</task>

<task type="auto">
  <name>Update public API exports</name>
  <files>src/index.ts</files>
  <action>
    Update src/index.ts to export transport types and classes:

    Add these exports after the existing type exports:

    ```typescript
    // Export transport types and classes
    export type { Transport } from './transports/transport';
    export { FileTransport, ConsoleTransport } from './transports';
    ```

    The full exports section should now be:
    ```typescript
    // Export types
    export type {
        LogLevel,
        LogEntry,
        LoggerConfig,
        Logger,
        ScopedLogger,
    } from './types';

    // Export transport types and classes
    export type { Transport } from './transports/transport';
    export { FileTransport, ConsoleTransport } from './transports';
    ```

    This allows users to import transports:
    ```typescript
    import { FileTransport, type Transport } from 'log-vibe';
    ```
  </action>
  <verify>
    File exports Transport type and transport classes:
    `grep -E "(Transport|FileTransport|ConsoleTransport)" src/index.ts`
  </verify>
  <done>
    Public API updated with:
    - Transport type export
    - FileTransport class export
    - ConsoleTransport class export
    - Clean import syntax for users
  </done>
</task>

</tasks>

<verification>
Type checking:
```bash
npx tsc --noEmit
```

Test backward compatibility (existing usage):
```bash
cat > /tmp/test-backward.js << 'EOF'
const log = require('./src/index.ts').default;
log.info('App', 'Testing backward compatibility');
log.success('Database', 'Connected');
log.warn('Cache', 'Missed key');
log.error('API', 'Request failed');
EOF
node /tmp/test-backward.js
```

Test transport configuration:
```bash
cat > /tmp/test-transports.js << 'EOF'
const { configure, FileTransport } = require('./src/index.ts');
const log = require('./src/index.ts').default;

// Test file shorthand
configure({ file: '/tmp/test.log' });
log.info('FileTest', 'Writing to file');

// Test explicit transports
configure({
  transports: [
    new FileTransport('/tmp/explicit.log'),
  ]
});
log.info('ExplicitTest', 'Writing to explicit file');
EOF
node /tmp/test-transports.js && cat /tmp/test.log && cat /tmp/explicit.log
```

Verify build succeeds:
```bash
npm run build
```
</verification>

<success_criteria>
- configure() accepts transports array
- configure() converts file shorthand to FileTransport
- Console transport is default (backward compatible)
- Logger writes to all configured transports
- Transport failures don't crash application
- Existing code works without modification
- All types exported correctly
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-transport-system/01-03-SUMMARY.md`
</output>
