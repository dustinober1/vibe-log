---
phase: 01-transport-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/transports/transport.ts
  - src/transports/index.ts
  - src/types.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Transport interface exists with log() method"
    - "Transport interface includes optional close() method"
    - "Transport type is exported from package"
    - "LoggerConfig extended with transport-related fields"
    - "All new types are backward compatible"
  artifacts:
    - path: "src/transports/transport.ts"
      provides: "Transport interface definition"
      exports: ["Transport"]
      min_lines: 20
    - path: "src/transports/index.ts"
      provides: "Transport exports barrel"
      exports: ["Transport"]
      min_lines: 5
    - path: "src/types.ts"
      provides: "Extended type definitions with transport support"
      contains: "transports"
      min_lines: 60
  key_links:
    - from: "src/transports/transport.ts"
      to: "src/types.ts"
      via: "import type { LogEntry, LoggerConfig }"
      pattern: "import.*from.*types"
---

<objective>
Create transport abstraction layer with TypeScript interfaces. Establish the contract that all transports must follow, enabling extensible log output destinations while maintaining type safety.

Purpose: Define the transport interface that will be implemented by file, console, and custom transports. This is the foundation for the entire transport system.

Output: Transport interface, extended LoggerConfig type, and public type exports.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-transport-system/01-CONTEXT.md
@.planning/phases/01-transport-system/01-RESEARCH.md

@src/types.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Create transport interface</name>
  <files>src/transports/transport.ts</files>
  <action>
    Create new file src/transports/transport.ts with Transport interface:

    ```typescript
    import type { LogEntry, LoggerConfig } from '../types';

    /**
     * Transport interface for log output destinations
     *
     * Transports receive formatted log strings and raw log entries,
     * enabling both simple output (write formatted string) and
     * advanced processing (analyze raw entry for custom formatting).
     */
    export interface Transport {
        /**
         * Write a log entry to this transport
         *
         * @param formatted - Formatted log string (with colors, icons, etc.)
         * @param entry - Raw log entry for custom formatting if needed
         * @param config - Current logger configuration (colors, icons, etc.)
         *
         * @remarks
         * This method MUST be synchronous. If a transport needs async
         * operations (e.g., network requests), it should handle them
         * internally without blocking the log call.
         *
         * This method MUST NOT throw. Errors should be caught and
         * handled gracefully (e.g., log to stderr as fallback).
         */
        log(formatted: string, entry: LogEntry, config: LoggerConfig): void;

        /**
         * Optional cleanup method for releasing resources
         *
         * Called when logger is destroyed or transport is removed.
         * Implement for transports that allocate resources (file handles,
         * network connections, etc.).
         *
         * @returns Promise that resolves when cleanup is complete
         *
         * @remarks
         * This method is optional. Transports that don't allocate resources
         * (e.g., console transport) can omit it.
         *
         * Users should call this during application shutdown to ensure
         * all logs are flushed and resources are released.
         */
        close?(): Promise<void> | void;
    }
    ```

    Do NOT:
    - Make log() return Promise (must be synchronous)
    - Add any runtime dependencies
    - Include implementation logic (interface only)
  </action>
  <verify>
    File exists at src/transports/transport.ts with:
    - Transport interface exported
    - log() method with correct signature
    - Optional close() method
    - Full JSDoc documentation
    - No implementation logic (interface only)

    Check: `cat src/transports/transport.ts | grep "export interface Transport"`
  </verify>
  <done>
    Transport interface defined with:
    - log(formatted: string, entry: LogEntry, config: LoggerConfig): void
    - Optional close() method returning Promise<void> | void
    - Comprehensive documentation explaining contract
  </done>
</task>

<task type="auto">
  <name>Create transports barrel export</name>
  <files>src/transports/index.ts</files>
  <action>
    Create src/transports/index.ts to re-export Transport interface:

    ```typescript
    export { Transport } from './transport';
    ```

    This creates a clean public API for the transports module.
  </action>
  <verify>
    File exists and exports Transport:
    `cat src/transports/index.ts | grep "export.*Transport"`
  </verify>
  <done>
    Transport interface re-exported from src/transports/index.ts for clean public API
  </done>
</task>

<task type="auto">
  <name>Extend LoggerConfig with transport fields</name>
  <files>src/types.ts</files>
  <action>
    Extend the LoggerConfig interface in src/types.ts to add transport support:

    Add these fields to the existing LoggerConfig interface (after timestampFormat, before closing brace):

    ```typescript
    /** File path shorthand for single file logging */
    file?: string;

    /** Array of transports (empty = no output, undefined = default console) */
    transports?: Transport[];

    /** Whether to include console transport in default transports */
    console?: boolean;
    ```

    Add forward reference for Transport type (at top of file after LogLevel type):

    ```typescript
    /**
     * Forward declaration for Transport interface
     * (defined in transports/transport.ts to avoid circular dependency)
     */
    export interface Transport {
        log(formatted: string, entry: LogEntry, config: LoggerConfig): void;
        close?(): Promise<void> | void;
    }
    ```

    CRITICAL: These are ADDITIVE changes only. Do NOT modify or remove existing fields.
    All new fields are optional to maintain backward compatibility.
  </action>
  <verify>
    src/types.ts contains:
    - Transport forward reference interface
    - file?: string in LoggerConfig
    - transports?: Transport[] in LoggerConfig
    - console?: boolean in LoggerConfig
    - All existing fields unchanged (level, showTimestamp, showIcons, useColors, maxDepth, timestampFormat)

    Check: `grep -E "(file|transports|console|\?\:)" src/types.ts | grep -v "//"`
  </verify>
  <done>
    LoggerConfig extended with:
    - Transport forward reference (avoids circular dependency)
    - file?: string for shorthand configuration
    - transports?: Transport[] for explicit transport array
    - console?: boolean for controlling default console transport
    - All existing fields preserved (backward compatible)
  </done>
</task>

</tasks>

<verification>
Run type checking to ensure no circular dependencies:
```bash
npx tsc --noEmit
```

Verify exports are accessible:
```bash
node -e "const t = require('./src/index.ts'); console.log(typeof t.Transport)"
```

Check backward compatibility (existing code should still compile):
```bash
npm run build
```
</verification>

<success_criteria>
- Transport interface defined with log() and optional close() methods
- LoggerConfig extended with file, transports, and console fields
- All types are backward compatible (existing code compiles without changes)
- TypeScript compilation succeeds with no errors
- Transport interface exported from package public API
</success_criteria>

<output>
After completion, create `.planning/phases/01-transport-system/01-01-SUMMARY.md`
</output>
