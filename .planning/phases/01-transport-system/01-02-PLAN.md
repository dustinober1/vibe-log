---
phase: 01-transport-system
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/transports/file-transport.ts
  - src/transports/console-transport.ts
  - src/transports/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FileTransport writes logs to specified file path"
    - "FileTransport creates directory if it doesn't exist"
    - "FileTransport handles write errors gracefully"
    - "FileTransport can be closed to release file handle"
    - "ConsoleTransport maps log levels to console methods"
    - "Both transports implement Transport interface"
  artifacts:
    - path: "src/transports/file-transport.ts"
      provides: "File transport implementation using Node.js streams"
      exports: ["FileTransport"]
      min_lines: 40
    - path: "src/transports/console-transport.ts"
      provides: "Console transport for standard output"
      exports: ["ConsoleTransport"]
      min_lines: 25
    - path: "src/transports/index.ts"
      provides: "Barrel exports for all transports"
      exports: ["Transport", "FileTransport", "ConsoleTransport"]
      min_lines: 5
  key_links:
    - from: "src/transports/file-transport.ts"
      to: "src/transports/transport.ts"
      via: "implements Transport"
      pattern: "class.*implements.*Transport"
    - from: "src/transports/console-transport.ts"
      to: "src/transports/transport.ts"
      via: "implements Transport"
      pattern: "class.*implements.*Transport"
    - from: "src/transports/file-transport.ts"
      to: "fs.createWriteStream"
      via: "Node.js built-in stream API"
      pattern: "fs\.createWriteStream"
---

<objective>
Implement file and console transports. Create production-ready transport implementations using Node.js built-in streams for efficient file writing and console methods for standard output.

Purpose: Provide concrete transport implementations that users can use immediately. File transport enables log persistence, console transport maintains backward compatibility.

Output: FileTransport and ConsoleTransport classes with full error handling and resource management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-transport-system/01-CONTEXT.md
@.planning/phases/01-transport-system/01-RESEARCH.md

@src/transports/transport.ts
@src/types.ts
@src/formatter.ts
</context>

<tasks>

<task type="auto">
  <name>Implement FileTransport class</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Create src/transports/file-transport.ts with FileTransport implementation:

    ```typescript
    import fs from 'fs';
    import path from 'path';
    import type { Transport } from './transport';
    import type { LogEntry, LoggerConfig } from '../types';

    /**
     * File transport for writing logs to a file
     *
     * Uses Node.js streams for efficient async file writing.
     * Creates parent directories automatically if they don't exist.
     */
    export class FileTransport implements Transport {
        private stream: fs.WriteStream;
        private filePath: string;

        /**
         * Create a new file transport
         *
         * @param filePath - Path to the log file (relative or absolute)
         *
         * @throws {Error} If filePath is empty or only whitespace
         *
         * @example
         * ```typescript
         * const transport = new FileTransport('./logs/app.log');
         * ```
         */
        constructor(filePath: string) {
            if (!filePath || !filePath.trim()) {
                throw new Error('File path cannot be empty or whitespace');
            }

            this.filePath = filePath;

            // Ensure directory exists (Node.js >= 10.12.0)
            const dir = path.dirname(filePath);
            try {
                fs.mkdirSync(dir, { recursive: true });
            } catch (error) {
                const err = error as NodeJS.ErrnoException;
                throw new Error(`Failed to create directory for log file: ${err.message}`);
            }

            // Create append stream with UTF-8 encoding
            this.stream = fs.createWriteStream(filePath, {
                flags: 'a',      // append mode
                encoding: 'utf8',
                mode: 0o666,     // read/write for all (modified by umask)
            });

            // Prevent crashes on stream errors (Critical: unhandled error events crash Node.js)
            this.stream.on('error', (err) => {
                // Fallback to console.error - don't throw, don't crash
                console.error(`[FileTransport] Write error for ${filePath}: ${err.message}`);
            });
        }

        /**
         * Write a log entry to the file
         *
         * @param formatted - Formatted log string
         * @param entry - Raw log entry (not used in file transport)
         * @param config - Logger config (not used in file transport)
         *
         * @remarks
         * This method is synchronous. The stream handles backpressure internally.
         * For high-volume logging, consider backpressure handling in Phase 2.
         */
        log(formatted: string): void {
            try {
                this.stream.write(formatted + '\n');
            } catch (error) {
                // Swallow errors - stream error handler will log to console
                // This prevents logging failures from crashing the application
            }
        }

        /**
         * Close the file stream and release the file handle
         *
         * @returns Promise that resolves when stream is closed
         *
         * @remarks
         * Call this during application shutdown to ensure all logs are flushed.
         * Not calling this may result in file handle leaks.
         */
        close(): Promise<void> {
            return new Promise((resolve, reject) => {
                // Remove error handler to avoid "Possible EventEmitter memory leak" warning
                this.stream.removeAllListeners('error');

                this.stream.end((err) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve();
                    }
                });
            });
        }
    }
    ```

    Key implementation details:
    - Uses fs.createWriteStream() for async, non-blocking writes
    - Creates directories with fs.mkdirSync({ recursive: true })
    - Attaches error handler to prevent crashes (MANDATORY for Node.js streams)
    - Swallows errors in log() to prevent logging failures from crashing app
    - close() returns Promise for proper async cleanup
    - Validates file path in constructor (fail fast)

    Do NOT:
    - Use fs.appendFile() (too slow for repeated calls)
    - Throw from log() method (crashes application)
    - Add external dependencies (use Node.js built-ins only)
    - Implement backpressure handling (defer to Phase 2 if needed)
  </action>
  <verify>
    File exists with:
    - FileTransport class implementing Transport
    - Constructor with filePath validation and directory creation
    - log() method writing formatted string + newline
    - close() method returning Promise<void>
    - Error handler attached to stream
    - No external dependencies (only fs and path from Node.js)

    Check: `cat src/transports/file-transport.ts | grep -E "(class FileTransport|implements Transport|private stream|log\(formatted|close\(\))"`
  </verify>
  <done>
    FileTransport implemented with:
    - Stream-based file writing (fs.createWriteStream)
    - Automatic directory creation
    - Error handling that prevents crashes
    - close() method for cleanup
    - Zero runtime dependencies
  </done>
</task>

<task type="auto">
  <name>Implement ConsoleTransport class</name>
  <files>src/transports/console-transport.ts</files>
  <action>
    Create src/transports/console-transport.ts with ConsoleTransport implementation:

    ```typescript
    import type { Transport } from './transport';
    import type { LogEntry, LoggerConfig } from '../types';

    /**
     * Console transport for writing logs to standard output
     *
     * Maps log levels to appropriate console methods (log, warn, error, debug).
     * This is the default transport for backward compatibility.
     */
    export class ConsoleTransport implements Transport {
        /**
         * Write a log entry to the console
         *
         * @param formatted - Formatted log string (with colors, icons, etc.)
         * @param entry - Raw log entry (used to determine console method)
         * @param config - Logger config (not used, formatter already applied)
         *
         * @remarks
         * This method maps log levels to console methods:
         * - error -> console.error
         * - warn -> console.warn
         * - debug -> console.debug
         * - info/success -> console.log
         *
         * The formatted string already contains colors, icons, and formatting
         * from the formatter, so this transport only needs to route to the
         * appropriate console method.
         */
        log(formatted: string, entry: LogEntry): void {
            // Map levels to console methods (same pattern as existing logger.ts)
            switch (entry.level) {
                case 'error':
                    console.error(formatted);
                    break;
                case 'warn':
                    console.warn(formatted);
                    break;
                case 'debug':
                    console.debug(formatted);
                    break;
                default:
                    // info and success both use console.log
                    console.log(formatted);
            }
        }

        /**
         * No-op cleanup method (console has no resources to release)
         *
         * @remarks
         * Console transport doesn't allocate resources, so this is a no-op.
         * Included for interface compatibility.
         */
        close(): void {
            // No resources to release
        }
    }
    ```

    Key implementation details:
    - Maps log levels to appropriate console methods
    - Uses existing pattern from logger.ts for consistency
    - close() is no-op (console has no resources)
    - Receives formatted string (colors already applied)

    Do NOT:
    - Add any formatting (formatter.ts handles this)
    - Throw exceptions (console methods are reliable)
    - Allocate resources (no cleanup needed)
  </action>
  <verify>
    File exists with:
    - ConsoleTransport class implementing Transport
    - log() method mapping levels to console methods
    - close() method (no-op implementation)
    - Correct switch statement for level mapping

    Check: `cat src/transports/console-transport.ts | grep -E "(class ConsoleTransport|implements Transport|console\.(error|warn|debug|log))"`
  </verify>
  <done>
    ConsoleTransport implemented with:
    - Level-aware console method routing
    - No resource allocation (no cleanup needed)
    - Consistent with existing logger.ts pattern
  </done>
</task>

<task type="auto">
  <name>Update transports barrel export</name>
  <files>src/transports/index.ts</files>
  <action>
    Update src/transports/index.ts to export all transports:

    ```typescript
    export { Transport } from './transport';
    export { FileTransport } from './file-transport';
    export { ConsoleTransport } from './console-transport';
    ```

    This creates a clean public API for importing transports.
  </action>
  <verify>
    File exports all three types:
    `cat src/transports/index.ts`
  </verify>
  <done>
    All transport types exported from src/transports/index.ts:
    - Transport (interface)
    - FileTransport (class)
    - ConsoleTransport (class)
  </done>
</task>

</tasks>

<verification>
Type checking with no errors:
```bash
npx tsc --noEmit
```

Verify imports work correctly:
```bash
node -e "const { FileTransport, ConsoleTransport } = require('./src/transports/index.ts'); console.log('FileTransport:', typeof FileTransport); console.log('ConsoleTransport:', typeof ConsoleTransport)"
```

Check for proper error handling:
```bash
# Test that FileTransport handles invalid path
node -e "try { const t = new (require('./src/transports/index.ts').FileTransport)(''); console.log('FAIL: Should have thrown'); } catch(e) { console.log('PASS: Threw error for empty path'); }"
```
</verification>

<success_criteria>
- FileTransport writes to file using streams
- FileTransport creates directories automatically
- FileTransport handles errors gracefully
- ConsoleTransport routes to correct console methods
- Both transports implement Transport interface correctly
- All transports exported from public API
- Zero runtime dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-transport-system/01-02-SUMMARY.md`
</output>
