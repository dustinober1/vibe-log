---
phase: 04-async-compression
plan: 03
type: execute
wave: 2
depends_on: [04-01, 04-02]
files_modified: [src/transports/file-transport.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FileTransport reads compressionLevel from RotationConfig"
    - "Compression starts after rotation completes with 10ms delay"
    - "Compression runs fire-and-forget (no await in rotation flow)"
    - "Compression errors logged but don't crash the application"
    - "Write gating prevents writes during compression scheduling"
  artifacts:
    - path: "src/transports/file-transport.ts"
      provides: "Compression scheduling after rotation"
      contains: "compressRotatedFile"
      min_lines: 20  # New compression scheduling code
  key_links:
    - from: "src/transports/file-transport.ts"
      to: "src/utils/compression.ts"
      via: "import compressRotatedFile"
      pattern: "import.*compressRotatedFile.*from.*compression"
    - from: "src/transports/file-transport.ts"
      to: "RotationConfig.compressionLevel"
      via: "FileTransportOptions interface"
      pattern: "compressionLevel\\?:\\s*number"
    - from: "performRotation method"
      to: "compressRotatedFile function"
      via: "setTimeout with 10ms delay"
      pattern: "setTimeout.*compressRotatedFile"
---

<objective>
Integrate compression scheduling into FileTransport rotation workflow

Purpose: Trigger fire-and-forget compression after rotation completes with 10ms delay to avoid CPU spikes
Output: FileTransport schedules compression after rotation with proper error handling
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/04-async-compression/04-CONTEXT.md
@.planning/phases/04-async-compression/04-RESEARCH.md
@src/transports/file-transport.ts
@src/utils/compression.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add compression scheduling to FileTransport</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Modify src/transports/file-transport.ts to add compression scheduling:

    1. Import compressRotatedFile utility (add to existing imports):
       ```typescript
       import { getMsUntilNextMidnightUTC, generateRotatedName } from '../utils/rotation';
       import { compressRotatedFile } from '../utils/compression';
       ```

    2. Update FileTransportOptions interface to include compressionLevel:
       ```typescript
       interface FileTransportOptions {
           maxSize?: string | number;
           pattern?: 'daily';
           compressionLevel?: number;  // Add this field
       }
       ```

    3. Add compressionLevel field to FileTransport class (after existing fields):
       ```typescript
       export class FileTransport implements Transport {
           private stream: fs.WriteStream;
           private readonly filePath: string;
           private closed = false;
           private readonly maxSize?: number;
           private readonly rotationEnabled: boolean;
           private readonly timeBasedRotationEnabled: boolean;
           private rotating = false;
           private rotationInProgress?: Promise<void>;
           private currentFileSize = 0;
           private rotationTimer?: NodeJS.Timeout;
           private lastRotationDate?: Date;
           private readonly compressionLevel?: number;  // Add this field
       ```

    4. Initialize compressionLevel in constructor (after existing rotation config parsing):
       ```typescript
       constructor(filePath: string, options?: FileTransportOptions) {
           // ... existing code ...

           // Parse rotation config if provided
           this.rotationEnabled = false;
           this.timeBasedRotationEnabled = false;
           this.compressionLevel = undefined;

           if (options !== undefined && options.maxSize !== undefined) {
               this.maxSize = parseSize(options.maxSize);
               this.rotationEnabled = true;
           }
           if (options !== undefined && options.pattern === 'daily') {
               this.timeBasedRotationEnabled = true;
               this.rotationEnabled = true;
           }

           // Add compression level parsing
           if (options !== undefined && options.compressionLevel !== undefined) {
               const level = options.compressionLevel;
               if (level < 1 || level > 9) {
                   throw new Error(`Compression level must be between 1 and 9, got ${level}`);
               }
               this.compressionLevel = level;
           }

           // ... rest of constructor ...
       }
       ```

    5. Update performRotation method to schedule compression (after rotation completes):
       ```typescript
       private async performRotation(): Promise<void> {
           return new Promise((resolve, reject) => {
               // Step 1: Close current stream
               this.stream.end((closeErr: Error | null | undefined) => {
                   if (closeErr) {
                       reject(closeErr);
                       return;
                   }

                   // Step 2: Rename file to date-stamped name
                   const rotatedPath = generateRotatedName(this.filePath);

                   fs.rename(this.filePath, rotatedPath, (renameErr: NodeJS.ErrnoException | null) => {
                       if (renameErr) {
                           // Rename failed â€” try to recover by reopening original file
                           this.stream = this.createWriteStream(this.filePath);
                           reject(renameErr);
                           return;
                       }

                       // Step 3: Create new stream for continued logging
                       this.stream = this.createWriteStream(this.filePath);

                       // Step 4: Reset file size counter
                       this.currentFileSize = 0;

                       // Step 5: Schedule compression with 10ms delay (fire-and-forget)
                       if (this.compressionLevel !== undefined) {
                           setTimeout(() => {
                               compressRotatedFile(rotatedPath, this.compressionLevel!)
                                   .catch((err) => {
                                       // Errors already logged in compressRotatedFile
                                       // This catch is just to prevent unhandled promise rejection
                                   });
                           }, 10);  // 10ms delay to avoid CPU spike during active logging
                       }

                       resolve();
                   });
               });
           });
       }
       ```

    DO NOT:
    - Do not await compressRotatedFile (fire-and-forget pattern)
    - Do not compress before rotation completes (must schedule after rename)
    - Do not reduce delay below 10ms (CONTEXT.md decision)
    - Do not throw errors from compression (logged in compressRotatedFile)
    - Do not compress if compressionLevel is undefined

    Implementation notes from CONTEXT.md and RESEARCH.md:
    - 10ms delay avoids CPU spike during active logging periods
    - Fire-and-forget: no await, compression runs asynchronously
    - Compression only if compressionLevel is defined
    - Errors logged in compressRotatedFile, this catch prevents unhandled rejection
    - Write gating (rotating flag) prevents writes during entire rotation+compression scheduling
  </action>
  <verify>
  Check that:
  - TypeScript compilation passes: `npm run build` or `tsc --noEmit`
  - compressRotatedFile imported from utils/compression
  - compressionLevel field added to FileTransportOptions and FileTransport class
  - Constructor validates compressionLevel is 1-9
  - performRotation schedules compression with 10ms setTimeout
  - Compression is fire-and-forget (no await)
  - Compression only runs if compressionLevel is defined
  </verify>
  <done>
  FileTransport integrates compression scheduling:
  - Reads compressionLevel from RotationConfig
  - Validates compressionLevel is 1-9
  - Schedules compression after rotation with 10ms delay
  - Fire-and-forget pattern (no blocking)
  - Errors logged but don't crash application
  </done>
</task>

</tasks>

<verification>
- TypeScript compilation successful
- FileTransport imports and uses compressRotatedFile utility
- Compression scheduled after rotation completes
- 10ms delay implemented to avoid CPU spikes
- Fire-and-forget pattern (no await in rotation flow)
- Compression level validation (1-9)
</verification>

<success_criteria>
FileTransport compression scheduling that:
- Reads compressionLevel from RotationConfig via FileTransportOptions
- Validates compressionLevel is between 1 and 9
- Schedules compression after rotation completes (not before)
- Uses 10ms setTimeout delay to avoid CPU spikes
- Runs fire-and-forget (no await, no blocking)
- Only compresses when compressionLevel is defined
- Handles errors gracefully (logged in compressRotatedFile)
</success_criteria>

<output>
After completion, create `.planning/phases/04-async-compression/04-03-SUMMARY.md`
</output>
