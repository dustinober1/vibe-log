---
phase: 04-async-compression
plan: 02
type: execute
wave: 1
depends_on: [04-01]
files_modified: [src/utils/compression.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "compressRotatedFile utility function exists"
    - "Function uses stream.pipeline() for robust error handling"
    - "Compression creates .gz file alongside original"
    - "Original file deleted after successful compression"
    - "Failed files moved to failed/ subdirectory"
    - "Partial .gz files cleaned up on error"
  artifacts:
    - path: "src/utils/compression.ts"
      provides: "compressRotatedFile utility function"
      exports: ["compressRotatedFile"]
      min_lines: 80
  key_links:
    - from: "src/utils/compression.ts"
      to: "node:zlib"
      via: "import createGzip"
      pattern: "import.*createGzip.*from.*zlib"
    - from: "src/utils/compression.ts"
      to: "node:stream/promises"
      via: "import pipeline"
      pattern: "import.*pipeline.*from.*stream"
    - from: "src/utils/compression.ts"
      to: "node:fs"
      via: "import fs"
      pattern: "import.*fs.*from.*fs"
---

<objective>
Create compressRotatedFile utility function using stream.pipeline() for async gzip compression

Purpose: Implement fire-and-forget compression with proper error handling and cleanup
Output: compressRotatedFile utility in src/utils/compression.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/04-async-compression/04-CONTEXT.md
@.planning/phases/04-async-compression/04-RESEARCH.md
@src/utils/rotation.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compressRotatedFile utility function</name>
  <files>src/utils/compression.ts</files>
  <action>
    Create new file src/utils/compression.ts with compressRotatedFile utility function:

    1. Import required modules:
       ```typescript
       import { createReadStream, createWriteStream } from 'node:fs';
       import { createGzip } from 'node:zlib';
       import { pipeline } from 'node:stream/promises';
       import fs from 'node:fs';
       import path from 'path';
       ```

    2. Create compressRotatedFile function:
       ```typescript
       /**
        * Compress a rotated log file using gzip
        *
        * @param filePath - Path to the rotated log file to compress
        * @param compressionLevel - Gzip compression level (1-9, default 6)
        * @returns Promise that resolves when compression completes or fails
        *
        * @remarks
        * This function implements fire-and-forget compression using stream.pipeline():
        * - Reads the rotated file via createReadStream
        * - Compresses using createGzip with specified level
        * - Writes to .gz file via createWriteStream
        * - Deletes original file after successful compression
        * - Moves failed files to failed/ subdirectory on error
        *
        * The pipeline() function automatically:
        * - Closes all streams on completion
        * - Propagates errors to the promise
        * - Cleans up partial output on error (deletes incomplete .gz files)
        *
        * @example
        * ```typescript
        * // Compress rotated file with level 6 (balanced)
        * await compressRotatedFile('./logs/app-2026-01-18.log.1', 6);
        * // Result: ./logs/app-2026-01-18.log.1.gz created, original deleted
        * ```
        */
       export async function compressRotatedFile(filePath: string, compressionLevel: number): Promise<void> {
           const destPath = `${filePath}.gz`;

           try {
               // Create streams
               const source = createReadStream(filePath);
               const gzip = createGzip({ level: compressionLevel });
               const destination = createWriteStream(destPath);

               // Use pipeline for proper error handling and cleanup
               await pipeline(source, gzip, destination);

               // Success: delete uncompressed file
               await fs.promises.unlink(filePath);

               // Log success to console for visibility
               console.log(`[FileTransport] Compressed: ${filePath} -> ${destPath}`);
           } catch (error) {
               const err = error as NodeJS.ErrnoException;
               console.error(`[FileTransport] Compression failed for ${filePath}: ${err.message}`);

               // Move failed file to failed/ subdirectory for manual inspection
               const failedDir = path.join(path.dirname(filePath), 'failed');
               await fs.promises.mkdir(failedDir, { recursive: true });
               const failedPath = path.join(failedDir, path.basename(filePath));

               try {
                   await fs.promises.rename(filePath, failedPath);
                   console.log(`[FileTransport] Moved failed file to: ${failedPath}`);
               } catch (renameError) {
                   // If rename fails (e.g., cross-device link), leave file in place
                   const renameErr = renameError as NodeJS.ErrnoException;
                   if (renameErr.code === 'EXDEV') {
                       console.error(`[FileTransport] Could not move failed file (cross-device link): ${filePath}`);
                   } else {
                       console.error(`[FileTransport] Could not move failed file: ${renameErr.message}`);
                   }
               }
           }
       }
       ```

    DO NOT:
    - Do not use zlib.gzip() (loads entire file into memory)
    - Do not use .pipe() chaining (doesn't handle errors correctly)
    - Do not delete original file before compression succeeds
    - Do not throw errors (log and continue per CONTEXT.md decision)

    Implementation notes from RESEARCH.md:
    - Use stream.pipeline() for automatic cleanup and error handling
    - Compression level passed to createGzip({ level })
    - Delete original only after successful compression
    - Move failed files to failed/ subdirectory (create if needed)
    - Handle EXDEV error for cross-device rename (leave file in place with warning)
  </action>
  <verify>
  Check that:
  - TypeScript compilation passes: `npm run build` or `tsc --noEmit`
  - File src/utils/compression.ts exists
  - Function signature: compressRotatedFile(filePath: string, compressionLevel: number): Promise<void>
  - Uses pipeline() from node:stream/promises
  - Uses createGzip() from node:zlib
  - Deletes original file after successful compression
  - Moves failed files to failed/ subdirectory
  - Handles EXDEV error for cross-device rename
  </verify>
  <done>
  compressRotatedFile utility function created with:
  - Stream-based compression using pipeline()
  - Automatic cleanup on error
  - Original file deletion after success
  - Failed file handling with failed/ directory
  - Cross-device rename error handling
  </done>
</task>

</tasks>

<verification>
- TypeScript compilation successful
- compressRotatedFile function exported from src/utils/compression.ts
- Function uses stream.pipeline() for proper error handling
- Error handling moves failed files to failed/ subdirectory
</verification>

<success_criteria>
compressRotatedFile utility function that:
- Uses stream.pipeline() for robust error handling and cleanup
- Compresses files asynchronously without blocking
- Deletes original file after successful compression
- Moves failed files to failed/ subdirectory for manual inspection
- Handles cross-device rename errors (EXDEV)
- Logs all operations to console for visibility
</success_criteria>

<output>
After completion, create `.planning/phases/04-async-compression/04-02-SUMMARY.md`
</output>
