---
phase: 05-retention-cleanup
plan: 04
type: execute
wave: 4
depends_on: [05-02, 05-03]
files_modified:
  - src/transports/file-transport.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Retention cleanup triggered after rotation completes"
    - "Cleanup uses fire-and-forget pattern (doesn't block rotation)"
    - "Cleanup errors emitted as 'error' events"
    - "Cleanup scheduled 20ms after compression (10ms + 10ms buffer)"
  artifacts:
    - path: "src/transports/file-transport.ts"
      provides: "FileTransport with integrated retention cleanup"
      contains: "performRetentionCleanup method"
  key_links:
    - from: "performRotation method"
      to: "performRetentionCleanup method"
      via: "setTimeout scheduling"
      pattern: "setTimeout.*performRetentionCleanup"
    - from: "performRetentionCleanup method"
      to: "cleanupOldLogs utility"
      via: "import and function call"
      pattern: "cleanupOldLogs"
    - from: "FileTransport error handler"
      to: "cleanup errors"
      via: "'error' event emission"
      pattern: "emit.*error.*retention"

---

<objective>
Integrate retention cleanup into FileTransport rotation flow using fire-and-forget pattern after rotation completes.

Purpose: Automatically delete old log files based on retention policy (maxFiles AND maxAge) after each rotation.
Output: FileTransport with integrated retention cleanup triggered after rotation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/05-retention-cleanup/05-CONTEXT.md
@.planning/phases/05-retention-cleanup/05-RESEARCH.md
@src/transports/file-transport.ts
@src/utils/retention.ts
@.planning/phases/05-retention-cleanup/05-02-SUMMARY.md
@.planning/phases/05-retention-cleanup/05-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Import cleanupOldLogs utility function</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Add import for cleanupOldLogs at the top of file-transport.ts (line 6, after compression import):

    import { cleanupOldLogs } from '../utils/retention';

    This imports the retention cleanup utility function implemented in plan 05-02.
  </action>
  <verify>
    grep "import.*cleanupOldLogs.*from.*retention" src/transports/file-transport.ts
  </verify>
  <done>
    cleanupOldLogs imported from utils/retention
    Import positioned logically after compression import
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement performRetentionCleanup private method</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Add private method performRetentionCleanup to FileTransport class (after clearRotationTimer method, around line 505):

    private async performRetentionCleanup(): Promise<void> {
        // Skip if retention config not set
        if (this.maxFiles === undefined || this.maxAge === undefined) {
            return;
        }

        // Extract directory, base filename, and extension
        const dir = path.dirname(this.filePath);
        const base = path.basename(this.filePath, path.extname(this.filePath));
        const ext = path.extname(this.filePath);

        // Perform cleanup
        const result = await cleanupOldLogs(dir, base, ext, this.maxFiles, this.maxAge);

        // Emit error event if any cleanup failures occurred
        if (result.errors.length > 0) {
            this.stream.emit('error', new Error(
                `Retention cleanup completed with ${result.errors.length} error(s): ${result.errors.join(', ')}`
            ));
        }
    }

    This method:
    - Returns early if retention not configured
    - Extracts file path components (dir, base, ext)
    - Calls cleanupOldLogs utility with retention config
    - Emits 'error' event if any deletions failed (non-fatal)
  </action>
  <verify>
    grep -A 20 "private async performRetentionCleanup" src/transports/file-transport.ts | head -25
  </verify>
  <done>
    performRetentionCleanup method implemented
    Returns early if retention not configured
    Calls cleanupOldLogs utility with correct parameters
    Emits 'error' event on cleanup failures (non-fatal)
    Method is async (Promise-based)
  </done>
</task>

<task type="auto">
  <name>Task 3: Schedule cleanup after rotation in performRotation</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    In the performRotation method (after line 362, after compression scheduling block):

    Add retention cleanup scheduling:

    // Step 6: Trigger retention cleanup if configured
    if (this.maxFiles !== undefined && this.maxAge !== undefined) {
        setTimeout(() => {
            this.performRetentionCleanup().catch((err) => {
                console.error(`[FileTransport] Retention cleanup error: ${err instanceof Error ? err.message : String(err)}`);
            });
        }, 20);  // 20ms delay after compression (10ms + 10ms buffer)
    }

    This schedules cleanup 20ms after rotation completes (after the 10ms compression delay).
    The fire-and-forget pattern ensures cleanup doesn't block rotation.
    Errors are logged to console and don't crash the application.
  </action>
  <verify>
    grep -A 10 "Step 6: Trigger retention cleanup" src/transports/file-transport.ts
  </verify>
  <done>
    Cleanup scheduled after rotation in performRotation
    20ms delay (after compression's 10ms delay)
    Fire-and-forget pattern (no await)
    Errors caught and logged to console
    Only runs if retention config is set
  </done>
</task>

</tasks>

<verification>
- cleanupOldLogs imported from utils/retention
- performRetentionCleanup method implemented
- Cleanup scheduled after rotation completes
- Fire-and-forget pattern (doesn't block rotation)
- 20ms delay after compression scheduling
- Errors emitted as 'error' events and logged to console
- TypeScript compiles without errors
</verification>

<success_criteria>
Retention cleanup integrated into FileTransport rotation flow
Cleanup triggered automatically after each rotation
Fire-and-forget pattern prevents blocking
Errors handled gracefully (non-fatal)
Ready for testing and documentation
</success_criteria>

<output>
After completion, create `.planning/phases/05-retention-cleanup/05-04-SUMMARY.md`
</output>
