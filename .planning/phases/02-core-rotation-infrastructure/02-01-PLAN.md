---
phase: 02-core-rotation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/transports/file-transport.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can configure size-based rotation via configure({ file, rotation: { maxSize } })"
    - "Rotation config is optional — existing code without rotation config continues working"
    - "Human-readable size strings ('100MB', '1.5GB') are parsed correctly to bytes"
    - "MaxSize defaults to 100MB when not specified"
  artifacts:
    - path: "src/types.ts"
      provides: "RotationConfig interface"
      contains: "interface RotationConfig"
    - path: "src/transports/file-transport.ts"
      provides: "Size parser utility and rotation config handling"
      exports: ["parseSize"]
  key_links:
    - from: "src/types.ts"
      to: "src/config.ts"
      via: "LoggerConfig.rotation field"
      pattern: "rotation\\?: RotationConfig"
    - from: "src/transports/file-transport.ts"
      to: "src/types.ts"
      via: "RotationConfig import"
      pattern: "import.*RotationConfig"
---

<objective>
Add rotation configuration types and size parsing utility to enable size-based log rotation.

Purpose: Establish the configuration contract and utility functions needed for rotation, without yet implementing the rotation logic itself. This provides the foundation for subsequent rotation implementation.

Output: RotationConfig type added to LoggerConfig, parseSize utility function, FileTransport constructor accepts rotation options.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-core-rotation-infrastructure/02-RESEARCH.md
@.planning/phases/02-core-rotation-infrastructure/02-CONTEXT.md
@.planning/codebase/CONVENTIONS.md

@src/types.ts
@src/transports/file-transport.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RotationConfig interface to types.ts</name>
  <files>src/types.ts</files>
  <action>
    Add RotationConfig interface to src/types.ts:

    ```typescript
    /**
     * Rotation configuration options
     *
     * @remarks
     * Rotation is an internal concern of FileTransport.
     * When rotation config is provided, FileTransport automatically
     * rotates log files when they exceed the size threshold.
     *
     * Size can be specified as:
     * - Number: Bytes (e.g., 104857600 for 100MB)
     * - String: Human-readable format (e.g., '100MB', '1.5GB', '500KB')
     *
     * Default maxSize: 100MB (104857600 bytes)
     */
    export interface RotationConfig {
        /** Maximum file size before rotation (default: '100MB') */
        maxSize?: string | number;
    }
    ```

    Then add rotation field to LoggerConfig interface:

    ```typescript
    export interface LoggerConfig {
        // ... existing fields ...
        /** File path shorthand for single file logging */
        file?: string;
        /** Rotation configuration for file transport */
        rotation?: RotationConfig;
        // ... rest of fields ...
    }
    ```

    Place RotationConfig BEFORE LoggerConfig (logical dependency order).
  </action>
  <verify>grep -q "interface RotationConfig" src/types.ts && grep -q "rotation\?: RotationConfig" src/types.ts</verify>
  <done>RotationConfig interface exists in types.ts with maxSize field, LoggerConfig has optional rotation field</done>
</task>

<task type="auto">
  <name>Task 2: Create parseSize utility in file-transport.ts</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Add parseSize utility function at the TOP of file-transport.ts (after imports, before class):

    ```typescript
    /**
     * Parse human-readable file size to bytes
     *
     * @param size - Size as number (bytes) or string (e.g., '100MB', '1.5GB', '500KB')
     * @returns Size in bytes
     * @throws {Error} If size string is invalid
     *
     * @example
     * ```typescript
     * parseSize('100MB');    // 104857600
     * parseSize('1.5GB');    // 1610612736
     * parseSize('500KB');    // 512000
     * parseSize(104857600);  // 104857600
     * ```
     */
    function parseSize(size: string | number): number {
        // If already a number, return as-is
        if (typeof size === 'number') {
            if (size <= 0) {
                throw new Error(`Size must be positive, got ${size}`);
            }
            return size;
        }

        // Parse string format: "100MB", "1.5GB", etc.
        const units: Record<string, number> = {
            'B': 1,
            'KB': 1024,
            'MB': 1024 ** 2,
            'GB': 1024 ** 3,
            'TB': 1024 ** 4,
            'PB': 1024 ** 5,
        };

        const trimmed = size.trim();
        const match = trimmed.match(/^([\d.]+)\s*([A-Z]+)$/i);

        if (!match) {
            throw new Error(`Invalid size format: "${size}". Expected format: "100MB", "1.5GB", etc.`);
        }

        const value = parseFloat(match[1]);
        const unit = match[2].toUpperCase();

        if (!(unit in units)) {
            throw new Error(`Unknown size unit: "${unit}". Supported: B, KB, MB, GB, TB, PB`);
        }

        const bytes = Math.round(value * units[unit]);

        if (bytes <= 0) {
            throw new Error(`Size must be positive, got "${size}" (${bytes} bytes)`);
        }

        return bytes;
    }
    ```

    Follow codebase conventions:
    - Use Record<> for dictionary types
    - Throw Error with descriptive messages
    - Use template literals for error messages
    - Include JSDoc with @param, @returns, @throws, @example
  </action>
  <verify>grep -q "function parseSize" src/transports/file-transport.ts && grep -q "const units: Record<string, number>" src/transports/file-transport.ts</verify>
  <done>parseSize function accepts string|number and returns bytes, throws on invalid format</done>
</task>

<task type="auto">
  <name>Task 3: Update FileTransport constructor to accept rotation config</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Modify FileTransport class to support rotation configuration:

    1. Add private fields (after existing fields):
    ```typescript
    export class FileTransport implements Transport {
        private stream: fs.WriteStream;
        private readonly filePath: string;
        private closed = false;
        private readonly maxSize?: number;  // ADD THIS
        private readonly rotationEnabled = false;  // ADD THIS
    ```

    2. Create FileTransportOptions interface (place before class):
    ```typescript
    /**
     * Options for FileTransport
     */
    interface FileTransportOptions {
        /** Maximum file size before rotation (e.g., '100MB', 104857600) */
        maxSize?: string | number;
    }
    ```

    3. Update constructor signature and implementation:
    ```typescript
    /**
     * Create a new file transport
     *
     * @param filePath - Path to the log file (relative or absolute)
     * @param options - Rotation options (optional, for future use)
     *
     * @throws {Error} If filePath is empty or only whitespace
     * @throws {Error} If rotation config has invalid size format
     *
     * @example
     * ```typescript
     * // Basic file logging (no rotation)
     * const transport = new FileTransport('./logs/app.log');
     *
     * // With rotation (future implementation)
     * const transport = new FileTransport('./logs/app.log', { maxSize: '100MB' });
     * ```
     */
    constructor(filePath: string, options?: FileTransportOptions) {
        if (!filePath || !filePath.trim()) {
            throw new Error('File path cannot be empty or whitespace');
        }

        this.filePath = filePath;

        // Parse rotation config if provided
        if (options?.maxSize) {
            this.maxSize = parseSize(options.maxSize);
            this.rotationEnabled = true;
        }

        // ... rest of existing constructor code (mkdir, createWriteStream, error handler) ...
    }
    ```

    Keep all existing constructor logic (directory creation, stream creation, error handler).
    Only ADD rotation field initialization — don't remove or change existing code.

    IMPORTANT: This is a NO-OP for rotation functionality — we're just storing the config.
    Actual rotation logic comes in later plans.
  </action>
  <verify>grep -q "private readonly maxSize" src/transports/file-transport.ts && grep -q "private readonly rotationEnabled" src/transports/file-transport.ts && grep -q "options?: FileTransportOptions" src/transports/file-transport.ts</verify>
  <done>FileTransport constructor accepts optional rotation config, parses maxSize using parseSize, stores in private fields</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Type checking: `npx tsc --noEmit` — should pass without errors
2. Verify backward compatibility: Existing code without rotation config still compiles
3. Verify rotation config: New code with rotation config compiles
4. Check parseSize edge cases: Test invalid formats throw errors

Run test suite: `npm test` — all existing tests should pass (we haven't broken anything).
</verification>

<success_criteria>
1. RotationConfig interface exists in types.ts with optional maxSize field
2. LoggerConfig has optional rotation field of type RotationConfig
3. parseSize utility function correctly parses '100MB', '1.5GB', '500KB' and raw numbers
4. FileTransport constructor accepts optional rotation options
5. maxSize is parsed and stored when rotation config provided
6. All existing tests pass — backward compatibility maintained
7. No rotation logic yet — just configuration and utilities
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rotation-infrastructure/02-01-SUMMARY.md`
</output>
