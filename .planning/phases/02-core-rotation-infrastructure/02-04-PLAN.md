---
phase: 02-core-rotation-infrastructure
plan: 04
type: execute
wave: 3
depends_on:
  - 02-01
  - 02-02
  - 02-03
files_modified:
  - src/transports/file-transport.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Write gating prevents concurrent writes during rotation"
    - "log() method checks file size and triggers rotation when threshold exceeded"
    - "No log entries are lost during rotation (writes blocked during performRotation)"
    - "Rotation state tracked via rotating flag"
  artifacts:
    - path: "src/transports/file-transport.ts"
      provides: "Size checking and rotation triggering in log() method"
      contains: "private rotating = false, private checkSizeAndRotate(), modified log()"
  key_links:
    - from: "log()"
      to: "rotating"
      via: "Write gate check"
      pattern: "if \\(this\\.rotating\\) return"
    - from: "log()"
      to: "checkSizeAndRotate"
      via: "Size check trigger"
      pattern: "this\\.checkSizeAndRotate\\("
    - from: "checkSizeAndRotate()"
      to: "performRotation"
      via: "Rotation execution"
      pattern: "await this\\.performRotation\\(\\)"
---

<objective>
Implement size checking and write gating to trigger rotation automatically when file size threshold is exceeded.

Purpose: Add the logic that checks file size on each write, triggers rotation when threshold is exceeded, and blocks concurrent writes during rotation to prevent data loss. This completes the rotation workflow.

Output: Modified log() method with size checking, write gating, and rotation triggering; new checkSizeAndRotate() private method for rotation logic; rotating flag for write gating.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-core-rotation-infrastructure/02-RESEARCH.md
@.planning/phases/02-core-rotation-infrastructure/02-CONTEXT.md
@.planning/codebase/CONVENTIONS.md
@src/transports/file-transport.ts
@.planning/phases/02-core-rotation-infrastructure/02-01-SUMMARY.md
@.planning/phases/02-core-rotation-infrastructure/02-02-SUMMARY.md
@.planning/phases/02-core-rotation-infrastructure/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rotation state tracking fields</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Add rotation state tracking fields to FileTransport class (after existing private fields):

    Find the private fields section:
    ```typescript
    export class FileTransport implements Transport {
        private stream: fs.WriteStream;
        private readonly filePath: string;
        private closed = false;
        private readonly maxSize?: number;
        private readonly rotationEnabled = false;
    ```

    Add these fields after rotationEnabled:
    ```typescript
        private rotating = false;              // Write gate flag
        private rotationInProgress?: Promise<void>;  // Track rotation promise
    ```

    These fields track rotation state:
    - `rotating`: Write gate flag — when true, log() calls skip writes
    - `rotationInProgress`: Promise tracking current rotation for deduplication

    Place them after the existing rotation config fields (maxSize, rotationEnabled).
  </action>
  <verify>grep -q "private rotating = false" src/transports/file-transport.ts && grep -q "private rotationInProgress" src/transports/file-transport.ts</verify>
  <done>Rotation state tracking fields added to FileTransport class</done>
</task>

<task type="auto">
  <name>Task 2: Add checkSizeAndRotate private method</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Add checkSizeAndRotate method to FileTransport class (place after performRotation method):

    ```typescript
    /**
     * Check file size and trigger rotation if threshold exceeded
     *
     * @param bytesAboutToWrite - Number of bytes that will be written
     *
     * @remarks
     * Uses fs.stat() to get current file size. If size + bytesAboutToWrite
     * exceeds maxSize, triggers rotation. Deduplicates concurrent rotation
     * checks by tracking rotationInProgress promise.
     *
     * This method is async but called fire-and-forget from log() to avoid
     * blocking writes. The rotating flag ensures no writes during rotation.
     */
    private async checkSizeAndRotate(bytesAboutToWrite: number): Promise<void> {
        // Skip if rotation not enabled or already rotating
        if (!this.rotationEnabled || this.rotating || this.rotationInProgress) {
            return;
        }

        try {
            // Get current file size
            const stats = await fs.promises.stat(this.filePath);
            const currentSize = stats.size;

            // Check if rotation needed
            if (currentSize + bytesAboutToWrite >= this.maxSize!) {
                // Set write gate BEFORE rotation starts
                this.rotating = true;

                // Perform rotation and track promise
                this.rotationInProgress = this.performRotation();

                try {
                    await this.rotationInProgress;
                } finally {
                    // Clear write gate AFTER rotation completes
                    this.rotating = false;
                    this.rotationInProgress = undefined;
                }
            }
        } catch (error) {
            // File doesn't exist or stat failed — log error but don't crash
            const err = error as NodeJS.ErrnoException;
            console.error(`[FileTransport] Size check failed: ${err.message}`);
        }
    }
    ```

    Implementation details from RESEARCH.md and CONTEXT.md:
    - Uses fs.promises.stat() for async size checking
    - Triggers rotation when currentSize + bytesAboutToWrite >= maxSize
    - Deduplicates rotation checks via rotationInProgress promise
    - Sets rotating flag BEFORE performRotation, clears AFTER
    - Gracefully handles ENOENT (file doesn't exist yet)
    - Fire-and-forget async pattern (called from sync log() without await)

    Add this method AFTER performRotation and BEFORE the closing brace of the class.
  </action>
  <verify>grep -q "private async checkSizeAndRotate" src/transports/file-transport.ts && grep -q "fs.promises.stat" src/transports/file-transport.ts</verify>
  <done>checkSizeAndRotate method checks file size and triggers rotation when threshold exceeded</done>
</task>

<task type="auto">
  <name>Task 3: Modify log() method to add write gating and size checking</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Modify the existing log() method to add write gating and size checking:

    Find the current log() method:
    ```typescript
    log(formatted: string, _entry: LogEntry, _config: LoggerConfig): void {
        try {
            this.stream.write(formatted + '\n');
        } catch (error) {
            // Swallow errors - stream error handler will log to console
        }
    }
    ```

    Replace it with:
    ```typescript
    /**
     * Write a log entry to the file
     *
     * @param formatted - Formatted log string
     * @param entry - Raw log entry (not used in file transport)
     * @param config - Logger config (not used in file transport)
     *
     * @remarks
     * Write gating: If rotation is in progress, skip this write to prevent
     * data loss during rotation. The rotation is atomic and will complete
     * before new writes are accepted.
     *
     * Size checking: Before writing, check if file size + this write will
     * exceed maxSize. If so, trigger rotation (fire-and-forget async).
     *
     * This method remains synchronous. Rotation happens asynchronously.
     */
    log(formatted: string, _entry: LogEntry, _config: LoggerConfig): void {
        // Write gating: skip writes during rotation
        if (this.rotating) {
            return;
        }

        const bytesAboutToWrite = formatted.length + 1; // +1 for newline

        try {
            this.stream.write(formatted + '\n');
        } catch (error) {
            // Swallow errors - stream error handler will log to console
            // This prevents logging failures from crashing the application
        }

        // Check size and potentially trigger rotation (fire-and-forget)
        if (this.rotationEnabled) {
            // Async call without await — don't block log() method
            this.checkSizeAndRotate(bytesAboutToWrite).catch((err) => {
                console.error(`[FileTransport] Rotation error: ${err instanceof Error ? err.message : String(err)}`);
            });
        }
    }
    ```

    Key changes:
    1. Add write gate check at top: `if (this.rotating) return;`
    2. Calculate bytesAboutToWrite for size check
    3. Keep existing stream.write() in try-catch
    4. Add fire-and-forget call to checkSizeAndRotate() after write
    5. Add error handler for rotation errors (non-blocking)

    IMPORTANT: The checkSizeAndRotate call is fire-and-forget (no await) to keep log() synchronous.
    This is the "hybrid size checking" pattern from CONTEXT.md — check size async, don't block writes.
  </action>
  <verify>grep -q "if (this.rotating)" src/transports/file-transport.ts && grep -q "this.checkSizeAndRotate" src/transports/file-transport.ts</verify>
  <done>log() method has write gating and triggers rotation when size threshold exceeded</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Type checking: `npx tsc --noEmit` — should pass
2. Verify write gating: log() returns early when rotating flag is true
3. Verify size checking: log() calls checkSizeAndRotate after write
4. Verify async pattern: checkSizeAndRotate is called fire-and-forget (no await)
5. Verify rotation sequence: rotating flag set before performRotation, cleared after

Code review checklist:
- [ ] Write gate prevents writes during rotation
- [ ] Size checking happens after write (non-blocking)
- [ ] Rotation triggered when size + write >= maxSize
- [ ] rotating flag set/cleared correctly
- [ ] rotationInProgress deduplicates concurrent checks
- [ ] Error handling doesn't crash the logger

Run existing tests: `npm test` — should all pass (rotation is opt-in via config).
</verification>

<success_criteria>
1. rotating and rotationInProgress fields added for state tracking
2. checkSizeAndRotate method implements size checking and rotation triggering
3. log() method has write gating (returns early when rotating)
4. log() method calls checkSizeAndRotate after each write
5. Rotation triggered when file size + write exceeds maxSize
6. Async rotation doesn't block log() method
7. All existing tests still pass
8. Rotation only happens when rotation config provided
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rotation-infrastructure/02-04-SUMMARY.md`
</output>
