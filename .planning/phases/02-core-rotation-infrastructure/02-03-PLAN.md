---
phase: 02-core-rotation-infrastructure
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
  - 02-02
files_modified:
  - src/transports/file-transport.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Rotation performs atomic close → rename → create new stream sequence"
    - "stream.end() is used (not stream.destroy()) to flush data before closing"
    - "New stream is created after rename for continued logging"
    - "Stream error handler is re-attached after rotation"
  artifacts:
    - path: "src/transports/file-transport.ts"
      provides: "performRotation method implementing atomic rotation sequence"
      contains: "private async performRotation(): Promise<void>"
  key_links:
    - from: "performRotation"
      to: "this.stream.end"
      via: "Stream flush and close"
      pattern: "this\\.stream\\.end\\("
    - from: "performRotation"
      to: "fs.rename"
      via: "Atomic file rename"
      pattern: "fs\\.rename\\("
    - from: "performRotation"
      to: "fs.createWriteStream"
      via: "New stream creation"
      pattern: "fs\\.createWriteStream\\("
---

<objective>
Implement atomic rotation sequence using close → rename → create new stream pattern.

Purpose: Execute the core rotation logic that safely closes the current stream, renames the file to a rotated name, and creates a new stream for continued logging. This ensures no log entries are lost during rotation.

Output: performRotation private method that safely rotates the log file using stream.end() for flush, fs.rename() for atomic rename, and creates new stream with proper error handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-core-rotation-infrastructure/02-RESEARCH.md
@.planning/phases/02-core-rotation-infrastructure/02-CONTEXT.md
@.planning/codebase/CONVENTIONS.md
@src/transports/file-transport.ts
@.planning/phases/02-core-rotation-infrastructure/02-01-SUMMARY.md
@.planning/phases/02-core-rotation-infrastructure/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add performRotation private method to FileTransport</name>
  <files>src/transports/file-transport.ts</files>
  <action>
    Add performRotation method to FileTransport class (place after the close method, before the closing brace):

    ```typescript
    /**
     * Perform atomic rotation: close stream → rename file → create new stream
     *
     * @returns Promise that resolves when rotation completes
     *
     * @remarks
     * Atomic rotation sequence:
     * 1. Close current stream (stream.end() flushes all buffered data)
     * 2. Rename file to date-stamped name (fs.rename is atomic on most filesystems)
     * 3. Create new stream for continued logging
     *
     * This method MUST be called with rotating flag set to prevent concurrent writes.
     *
     * @throws {Error} If stream close fails
     * @throws {Error} If file rename fails
     */
    private async performRotation(): Promise<void> {
        return new Promise((resolve, reject) => {
            // Step 1: Close current stream (flushes all buffered data)
            this.stream.end((closeErr: Error | null | undefined) => {
                if (closeErr) {
                    reject(closeErr);
                    return;
                }

                // Step 2: Rename file to date-stamped name
                const rotatedPath = generateRotatedName(this.filePath);

                fs.rename(this.filePath, rotatedPath, (renameErr: NodeJS.ErrnoException | null) => {
                    if (renameErr) {
                        // Rename failed — try to recover by reopening original file
                        this.stream = fs.createWriteStream(this.filePath, {
                            flags: 'a',
                            encoding: 'utf8',
                            mode: 0o666,
                        });

                        // Re-attach error handler
                        this.stream.on('error', (err) => {
                            console.error(`[FileTransport] Write error for ${this.filePath}: ${err.message}`);
                        });

                        reject(renameErr);
                        return;
                    }

                    // Step 3: Create new stream for continued logging
                    this.stream = fs.createWriteStream(this.filePath, {
                        flags: 'a',
                        encoding: 'utf8',
                        mode: 0o666,
                    });

                    // Re-attach error handler to new stream
                    this.stream.on('error', (err) => {
                        console.error(`[FileTransport] Write error for ${this.filePath}: ${err.message}`);
                    });

                    resolve();
                });
            });
        });
    }
    ```

    Implementation details from RESEARCH.md:
    - Use `stream.end()` (NOT `stream.destroy()`) to ensure data flush
    - Follow atomic sequence: close → rename → create new stream
    - Error recovery: if rename fails, reopen original file to allow logging to continue
    - Re-attach error handler to new stream after rotation
    - All steps use callback-based APIs for consistency with existing code
    - Wrapped in Promise for async/await compatibility

    Add this method AFTER the close() method and BEFORE the closing brace of the class.
  </action>
  <verify>grep -q "private async performRotation" src/transports/file-transport.ts && grep -q "this.stream.end" src/transports/file-transport.ts && grep -q "fs.rename" src/transports/file-transport.ts</verify>
  <done>performRotation method implements atomic close → rename → create new stream sequence with error recovery</done>
</task>

</tasks>

<verification>
After completing the task:

1. Type checking: `npx tsc --noEmit` — should pass
2. Verify method placement: performRotation is private and async
3. Verify atomic sequence: stream.end() → fs.rename() → createWriteStream()
4. Verify error recovery: Rename failure reopens original file
5. Verify error handler: New stream gets error handler attached

Code review checklist:
- [ ] Uses stream.end() NOT stream.destroy()
- [ ] All three steps present (close, rename, create)
- [ ] Error recovery on rename failure
- [ ] Error handler re-attached to new stream
- [ ] Method is private (internal implementation detail)
</verification>

<success_criteria>
1. performRotation private method exists in FileTransport class
2. Method follows atomic sequence: close → rename → create new stream
3. Uses stream.end() for safe data flush (not stream.destroy())
4. Creates new stream with same options as original (append mode, utf8, 0o666)
5. Re-attaches error handler to new stream
6. Has error recovery if rename fails (reopens original file)
7. All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rotation-infrastructure/02-03-SUMMARY.md`
</output>
