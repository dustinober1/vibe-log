---
phase: 02-core-rotation-infrastructure
plan: 06
type: execute
wave: 5
depends_on:
  - 02-01
  - 02-02
  - 02-03
  - 02-04
  - 02-05
files_modified:
  - src/config.ts
  - src/logger.ts
  - README.md
  - test/integration.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can configure rotation via configure({ file, rotation: { maxSize } })"
    - "Existing code without rotation config continues working unchanged"
    - "README documents rotation configuration with examples"
    - "Integration test verifies end-to-end rotation workflow"
  artifacts:
    - path: "src/config.ts"
      provides: "configure() function with rotation support"
      contains: "rotation field handling"
    - path: "src/logger.ts"
      provides: "FileTransport instantiation with rotation config"
      contains: "FileTransport constructor with rotation options"
    - path: "README.md"
      provides: "Rotation documentation and examples"
      contains: "Rotation section"
    - path: "test/integration.test.ts"
      provides: "Integration test for rotation workflow"
      contains: "describe block for rotation"
  key_links:
    - from: "src/config.ts"
      to: "src/transports/file-transport.ts"
      via: "FileTransportOptions with rotation config"
      pattern: "new FileTransport.*rotation"
    - from: "README.md"
      to: "src/types.ts"
      via: "RotationConfig interface documentation"
      pattern: "RotationConfig"
---

<objective>
Integrate rotation configuration into the public API, write integration tests, and document rotation functionality in README.

Purpose: Wire up rotation configuration through the configure() function, verify end-to-end functionality with integration tests, and provide user-facing documentation for rotation features.

Output: Working configure({ rotation }) API, integration test confirming rotation workflow, README documentation with examples.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-core-rotation-infrastructure/02-RESEARCH.md
@.planning/phases/02-core-rotation-infrastructure/02-CONTEXT.md
@.planning/codebase/CONVENTIONS.md
@src/config.ts
@src/logger.ts
@README.md
@test/config-transport.test.ts
@.planning/phases/02-core-rotation-infrastructure/02-01-SUMMARY.md
@.planning/phases/02-core-rotation-infrastructure/02-02-SUMMARY.md
@.planning/phases/02-core-rotation-infrastructure/02-03-SUMMARY.md
@.planning/phases/02-core-rotation-infrastructure/02-04-SUMMARY.md
@.planning/phases/02-core-rotation-infrastructure/02-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update configure() function to handle rotation config</name>
  <files>src/config.ts</files>
  <action>
    Modify src/config.ts to pass rotation config to FileTransport:

    Find the section where FileTransport is created (likely in the configure function or where file option is processed):

    ```typescript
    // Existing code likely looks like:
    if (config.file) {
        const fileTransport = new FileTransport(config.file);
        // ... add to transports
    }
    ```

    Update it to:

    ```typescript
    // File shorthand for single file logging
    if (config.file) {
        const { file, rotation, ...restOfConfig } = config;

        // Type-safe FileTransport options
        const fileTransportOptions: FileTransportOptions = {};

        if (rotation) {
            fileTransportOptions.maxSize = rotation.maxSize;
        }

        const fileTransport = new FileTransport(file, fileTransportOptions);
        newTransports.push(fileTransport);
    }
    ```

    IMPORTANT: We need to import or define FileTransportOptions type.
    Since it's defined in file-transport.ts as an internal interface, we have two options:

    Option A: Export FileTransportOptions from file-transport.ts
    Option B: Don't type the options object (let TypeScript infer it)

    Use Option B for now (simpler, no breaking changes):

    ```typescript
    // File shorthand for single file logging
    if (config.file) {
        const { file, rotation, ...restOfConfig } = config;

        // Build FileTransport options if rotation config provided
        const fileTransportOptions: { maxSize?: string | number } = {};

        if (rotation?.maxSize) {
            fileTransportOptions.maxSize = rotation.maxSize;
        }

        const fileTransport = new FileTransport(
            file,
            Object.keys(fileTransportOptions).length > 0 ? fileTransportOptions : undefined
        );
        newTransports.push(fileTransport);
    }
    ```

    Only pass options if they're not empty (undefined if no rotation config).
    This maintains backward compatibility.

    If FileTransport doesn't accept undefined options, update the constructor:
    ```typescript
    constructor(filePath: string, options?: FileTransportOptions) {
        // If options is undefined, treat as no rotation
        // ...
    }
    ```

    Make minimal changes to preserve existing functionality.
  </action>
  <verify>grep -q "rotation?.maxSize" src/config.ts</verify>
  <done>configure() function passes rotation config to FileTransport when provided</done>
</task>

<task type="auto">
  <name>Task 2: Update custom transports handling to support rotation</name>
  <files>src/config.ts</files>
  <action>
    Review the configure() function to ensure rotation config works with custom transports.

    If the user creates their own FileTransport with rotation:

    ```typescript
    import { configure } from 'log-vibe';
    import { FileTransport } from 'log-vibe/transports';

    configure({
        transports: [
            new FileTransport('./app.log', { maxSize: '100MB' })
        ]
    });
    ```

    This should already work since FileTransport constructor accepts options.
    No changes needed — this is about VERIFYING it works.

    However, if the rotation field in LoggerConfig is meant to apply to ALL FileTransports
    (including user-created ones), that's more complex. Based on CONTEXT.md, rotation
    is only for the file shorthand, not custom transports.

    So no changes needed here — just verify the file shorthand handling from Task 1 works.

    Add a comment in config.ts to document this:

    ```typescript
    // Note: Rotation config only applies to file shorthand (config.file).
    // For custom FileTransport instances, pass options directly to constructor:
    // new FileTransport('./app.log', { maxSize: '100MB' })
    ```

    This clarifies the design decision.
  </action>
  <verify>grep -q "Rotation config only applies to file shorthand" src/config.ts</verify>
  <done>Comment added documenting rotation config scope (file shorthand only)</done>
</task>

<task type="auto">
  <name>Task 3: Create integration test for rotation workflow</name>
  <files>test/integration.test.ts</files>
  <action>
    Add integration test to verify end-to-end rotation workflow:

    First, check if test/integration.test.ts exists. If not, create it:

    ```typescript
    import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
    import fs from 'node:fs/promises';
    import path from 'node:path';
    import { configure, resetConfig } from '../src/config';
    import { log } from '../src/logger';
    import { FileTransport } from '../src/transports/file-transport';

    describe('Rotation integration', () => {
        const testDir = path.join(process.cwd(), 'test-logs');
        const testFile = path.join(testDir, 'integration.log');

        beforeEach(async () => {
            // Clean up test directory
            try {
                await fs.rm(testDir, { recursive: true, force: true });
            } catch {
                // Directory doesn't exist
            }
            await fs.mkdir(testDir, { recursive: true });

            // Reset config
            resetConfig();
        });

        afterEach(async () => {
            // Clean up test directory
            try {
                await fs.rm(testDir, { recursive: true, force: true });
            } catch {
                // Directory doesn't exist
            }

            // Reset config
            resetConfig();
        });

        it('should rotate log file when size exceeds threshold', async () => {
            // Configure with small rotation threshold
            configure({
                file: testFile,
                rotation: { maxSize: '1KB' },
                console: false, // Disable console output
            });

            // Write enough logs to trigger rotation
            for (let i = 0; i < 20; i++) {
                log.info('test', `Log entry ${i} with some padding text`);
            }

            // Wait for async rotation to complete
            await new Promise(resolve => setTimeout(resolve, 500));

            // Verify rotated file exists
            const files = await fs.readdir(testDir);
            const rotatedFiles = files.filter(f => f.includes('integration-') && f.endsWith('.log.1'));

            expect(rotatedFiles.length).toBeGreaterThan(0);
        });

        it('should not rotate when rotation config not provided', async () => {
            // Configure without rotation
            configure({
                file: testFile,
                console: false,
            });

            // Write logs
            for (let i = 0; i < 10; i++) {
                log.info('test', `Log entry ${i}`);
            }

            // Wait for any async operations
            await new Promise(resolve => setTimeout(resolve, 100));

            // Verify no rotated files
            const files = await fs.readdir(testDir);
            const rotatedFiles = files.filter(f => f.includes('.log.'));

            expect(rotatedFiles.length).toBe(0);
        });

        it('should support custom FileTransport with rotation', async () => {
            // Configure with custom FileTransport
            const customTransport = new FileTransport(testFile, { maxSize: '1KB' });

            configure({
                transports: [customTransport],
                console: false,
            });

            // Write logs
            for (let i = 0; i < 20; i++) {
                log.info('test', `Log entry ${i} with padding`);
            }

            // Wait for rotation
            await new Promise(resolve => setTimeout(resolve, 500));

            // Verify rotation occurred
            const files = await fs.readdir(testDir);
            const rotatedFiles = files.filter(f => f.includes('.log.'));

            expect(rotatedFiles.length).toBeGreaterThan(0);
        });
    });
    ```

    Create test/integration.test.ts with these integration tests.
    Tests verify:
    1. Rotation triggers when size threshold exceeded
    2. No rotation when config not provided (backward compatibility)
    3. Custom FileTransport with rotation options works
  </action>
  <verify>grep -q "describe('Rotation integration'" test/integration.test.ts</verify>
  <done>Integration tests created for rotation workflow</done>
</task>

<task type="auto">
  <name>Task 4: Add rotation documentation to README</name>
  <files>README.md</files>
  <action>
    Add rotation documentation section to README.md:

    Find the appropriate place (after "Transports" section, before or after "Examples").
    Add a new section:

    ```markdown
    ## Log Rotation

    log-vibe supports automatic log rotation based on file size. When a log file exceeds the configured size threshold, it's automatically rotated to a date-stamped archive and a new log file is created.

    ### Configuration

    Enable rotation via the `rotation` option:

    ```typescript
    import { configure } from 'log-vibe';

    configure({
        file: './logs/app.log',
        rotation: {
            maxSize: '100MB'  // Rotate when file exceeds 100MB
        }
    });
    ```

    ### Size Format

    The `maxSize` option accepts:

    - **String**: Human-readable format like `'100MB'`, `'1.5GB'`, `'500KB'`
    - **Number**: Raw bytes like `104857600` (100MB)

    Default: `'100MB'` if not specified.

    ### Rotated File Naming

    Rotated files follow this pattern:

    ```
    {basename}-{YYYY-MM-DD}.{ext}.{sequence}
    ```

    Examples:
    - `app-2026-01-18.log.1` (first rotation on Jan 18, 2026)
    - `app-2026-01-18.log.2` (second rotation on same day)
    - `app-2026-01-19.log.1` (first rotation on Jan 19, 2026)

    **Timezone**: Uses UTC to ensure consistency across servers.

    ### Backward Compatibility

    Rotation is **opt-in**. Existing code without rotation config continues working unchanged:

    ```typescript
    // No rotation — logs grow indefinitely
    configure({ file: './app.log' });

    // With rotation — logs are automatically rotated
    configure({
        file: './app.log',
        rotation: { maxSize: '100MB' }
    });
    ```

    ### Custom FileTransport with Rotation

    For advanced use cases with custom transports:

    ```typescript
    import { configure } from 'log-vibe';
    import { FileTransport } from 'log-vibe/transports';

    const transport = new FileTransport('./logs/app.log', {
        maxSize: '50MB'
    });

    configure({ transports: [transport] });
    ```

    ### How It Works

    1. **Size Check**: After each log write, the file size is checked
    2. **Rotation Trigger**: If size + write ≥ maxSize, rotation starts
    3. **Write Gating**: Concurrent writes are blocked during rotation
    4. **Atomic Rotation**: Stream closes → file renamed → new stream created
    5. **Resume**: Logging continues with new file

    **Important**: Rotation is atomic — no log entries are lost during rotation.
    ```

    Place this section in the README where it makes logical sense (likely after Transports section).
    Ensure markdown formatting is correct and code examples are properly fenced.
  </action>
  <verify>grep -q "## Log Rotation" README.md && grep -q "rotation: {" README.md</verify>
  <done>README updated with rotation documentation and examples</done>
</task>

<task type="auto">
  <name>Task 5: Update README table of contents (if present)</name>
  <files>README.md</files>
  <action>
    If README.md has a table of contents, add an entry for the Log Rotation section.

    Look for a section like:
    ```markdown
    - [Transports](#transports)
    - [Examples](#examples)
    ```

    Add:
    ```markdown
    - [Transports](#transports)
    - [Log Rotation](#log-rotation)
    - [Examples](#examples)
    ```

    If no table of contents exists, skip this task.
  </action>
  <verify>grep -q "[Log Rotation](#log-rotation)" README.md || true</verify>
  <done>Table of contents updated (if present)</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Type checking: `npx tsc --noEmit` — should pass
2. Run all tests: `npm test` — all tests should pass
3. Run integration tests: `npm test -- test/integration.test.ts` — verify rotation workflow
4. Verify backward compatibility: Tests without rotation config still pass
5. Check README: Rotation section exists with examples
6. Manual verification (optional):
   - Create a small test script that uses rotation
   - Verify rotation occurs when file size exceeded

Integration test checklist:
- [ ] Rotation triggers when size threshold exceeded
- [ ] No rotation when config not provided
- [ ] Custom FileTransport with rotation works
- [ ] Test cleanup (files deleted after tests)
</verification>

<success_criteria>
1. configure() function supports rotation config
2. Rotation config passed to FileTransport when using file shorthand
3. Integration tests verify end-to-end rotation workflow
4. README documents rotation with clear examples
5. Backward compatibility maintained (existing code works unchanged)
6. All tests passing (including new integration tests)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rotation-infrastructure/02-06-SUMMARY.md`
</output>
